<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>01世界</title>
  
  <subtitle>「0和1的世界|从0到1」</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hbiboluo.com/"/>
  <updated>2019-02-22T00:57:34.354Z</updated>
  <id>https://www.hbiboluo.com/</id>
  
  <author>
    <name>hbiboluo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>短评《如何阅读一本书》</title>
    <link href="https://www.hbiboluo.com/2019/02/21/how_to_read_a_book/"/>
    <id>https://www.hbiboluo.com/2019/02/21/how_to_read_a_book/</id>
    <published>2019-02-20T16:00:00.000Z</published>
    <updated>2019-02-22T00:57:34.354Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/img/reading.jpg" alt="如何阅读一本书"></p><p>简单总结《如何阅读一本书》中目前个人理解的要点。</p><h1 id="主动阅读"><a href="#主动阅读" class="headerlink" title="主动阅读"></a>主动阅读</h1><h2 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h2><ul><li>书的金字塔原则：好书是有限的，知无涯而生有涯<ul><li>聚焦在少数真正有提升的书籍</li><li>花合适的成本去阅读对应书籍</li><li>有必要在限定时间内了解一本书是否值得花更多时间、精力去研习</li></ul></li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>阅读目标：学习、提升</li><li>阅读过程：从文字中理解作者想表达的的思想：主题、思路框架、主旨及论点……<ul><li>越是与目前能力有差距的书，越要付出更多的时间、精力以及理解力。</li><li>合理的期望：提升大的书，需要逐次逐步阅读。</li><li>避免口语主义：反模式是记住了原话，而没有理解真义。所以最好的方式是<strong>用自己的话来表达</strong>！</li></ul></li><li>阅读成果：阅读目标的答卷<ul><li>学以致用</li><li>知行合一，深知深行，浅知浅行，不知不行</li></ul></li></ul><h1 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h1><p>这些方法是为指导我们阅读时要达成的小目标，也是作者理想的最佳实践。</p><p>完全遵循书中的规则偏理想，可以把它们看成是否完成该层次阅读的验收标准。</p><h2 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h2><ul><li>重点：限时！</li><li>目标：了解主题、框架以及主要解决问题，以及是否有价值花更多时间做更完整的阅读。</li><li>要点：<ul><li>SOP：系统性略读</li><li>粗浅的阅读：在限定时间内，安排好时间、精力快速读完一遍<ul><li>特别是在难懂的地方不要停下来，在价值不大的地方不要做太多投入</li><li>特别要注意找到作者自己的总结，一般在首章或末章</li></ul></li></ul></li></ul><h2 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h2><p>完成以下内容：</p><ul><li>书内<ul><li>框架性 - 透视一本书</li><li>内容性 - 诠释一本书</li></ul></li><li>书外<ul><li>平等性 - 评断一本书</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/img/reading.jpg&quot; alt=&quot;如何阅读一本书&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单总结《如何阅读一本书》中目前个人理解的要点。&lt;/p&gt;
&lt;h1 id=&quot;主动阅读&quot;&gt;&lt;a href=&quot;#主动阅读&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="读书" scheme="https://www.hbiboluo.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="阅读" scheme="https://www.hbiboluo.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="读书笔记" scheme="https://www.hbiboluo.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何避免MySQL死锁（五）- 实例分析</title>
    <link href="https://www.hbiboluo.com/2019/01/11/avoid-mysql-deadlock-5/"/>
    <id>https://www.hbiboluo.com/2019/01/11/avoid-mysql-deadlock-5/</id>
    <published>2019-01-11T15:00:00.000Z</published>
    <updated>2019-01-13T05:10:37.178Z</updated>
    
    <content type="html"><![CDATA[<p>注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论<code>InnoDB</code>引擎。</p><ol><li><a href="/2019/01/06/avoid-mysql-deadlock-1/">如何避免MySQL死锁（一）- 引子</a></li><li><a href="/2019/01/06/avoid-mysql-deadlock-2/">如何避免MySQL死锁（二）- MySQL锁</a></li><li><a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a></li><li><a href="/2019/01/08/avoid-mysql-deadlock-4/">如何避免MySQL死锁（四）- 阅读死锁日志</a></li><li><a href="/2019/01/11/avoid-mysql-deadlock-5/">如何避免MySQL死锁（五）- 实例分析</a></li></ol><hr><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>新建表结构:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`U_name`</span>(<span class="string">`name`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">6</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></p><p>插入数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">'One'</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'Two'</span>),</span><br><span class="line">  (<span class="number">3</span>, <span class="string">'Three'</span>),</span><br><span class="line">  (<span class="number">5</span>, <span class="string">'Five'</span>);</span><br></pre></td></tr></table></figure></p><p>注意模拟之后，<code>rollback</code>回滚事务。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="1、加锁顺序问题"><a href="#1、加锁顺序问题" class="headerlink" title="1、加锁顺序问题"></a>1、加锁顺序问题</h2><h3 id="1-1-显式：相同索引的加锁顺序"><a href="#1-1-显式：相同索引的加锁顺序" class="headerlink" title="1.1 显式：相同索引的加锁顺序"></a>1.1 显式：相同索引的加锁顺序</h3><table><thead><tr><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>update user set name=’O’ where id=1;</td><td></td></tr><tr><td></td><td>update user set name=’T’ where id=2;</td></tr><tr><td>update user set name=’T’ where id=2;</td><td></td></tr><tr><td></td><td>update user set name=’O’ where id=1;</td></tr></tbody></table><h3 id="1-2-隐式：不同索引的加锁顺序"><a href="#1-2-隐式：不同索引的加锁顺序" class="headerlink" title="1.2 隐式：不同索引的加锁顺序"></a>1.2 隐式：不同索引的加锁顺序</h3><table><thead><tr><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>update user set name=’O’ where id=1;</td><td></td></tr><tr><td></td><td>update user set name=’T’ where name=’TWO’;</td></tr><tr><td>update user set name=’T’ where id=2;</td><td></td></tr><tr><td></td><td>update user set name=’O’ where name=’ONE’;</td></tr></tbody></table><p>走不同的索引可能会导致在聚簇索引上的不同加锁顺序，以上的示例是简单的场景，实际场景上要非常注意以下情况：</p><ul><li>即使是相同语句，不同value的查询可能也会走不同的索引，切记，具体要看日志来。走什么索引是由优化器决定。</li></ul><h2 id="2、锁升级"><a href="#2、锁升级" class="headerlink" title="2、锁升级"></a>2、锁升级</h2><p>delete标记导致的不同加锁策略，普通的等值查询加锁在<code>RR</code>事务级别下是这样的：</p><ul><li>找到满足条件的记录：加REC锁</li><li>没找到满足条件的记录：加Gap锁</li><li><strong>特别的，找到了满足条件的记录但是被标记为delete：加NK锁</strong></li></ul><p>前文<a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a>介绍了SQL语句是逐行加锁，逐行操作的。<br>高并发情况下(3个事务及其以上)，可能会出现同时申请获取delete的REC锁，事务排队后获取时发现记录已被删除，将在不释放锁的前提下重新去获取Gap锁（二阶段锁协议），如果此时另一个事务已经提前去排队取NK锁，凉凉。。。</p><h2 id="3、操作的非原子性"><a href="#3、操作的非原子性" class="headerlink" title="3、操作的非原子性"></a>3、操作的非原子性</h2><h3 id="3-1-唯一键插入的两过程"><a href="#3-1-唯一键插入的两过程" class="headerlink" title="3.1 唯一键插入的两过程"></a>3.1 唯一键插入的两过程</h3><ul><li>先进行一次唯一键的冲突检测，加 (LOCK_GAP | LOCK_REC | LOCK_S)，共享锁</li><li>然后才获取插入意向锁，加(LOCK_INSERT_INTENTION | LOCK_GAP | LOCK_X )，写锁</li></ul><table><thead><tr><th>事务1</th><th>事务2</th><th>事务3</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td><td>start transaction;</td></tr><tr><td>insert into user values(6, ‘Six’)</td><td></td><td></td></tr><tr><td></td><td>insert into user values(6, ‘Six’)</td><td></td></tr><tr><td></td><td></td><td>insert into user values(6, ‘Six’)</td></tr><tr><td>rollback;</td><td>-</td><td>-</td></tr></tbody></table><p>事务2、3同时持有共享的NK锁，插入意向锁循环等待。（除了以上示例，高并发场景下，有可能出现）</p><h3 id="3-2-删除-等值查询-的两过程"><a href="#3-2-删除-等值查询-的两过程" class="headerlink" title="3.2 删除(等值查询)的两过程"></a>3.2 删除(等值查询)的两过程</h3><ul><li>获取REC锁</li><li>标记为删除</li></ul><p>参见：「2、锁升级」</p><h2 id="4、先删除再插入"><a href="#4、先删除再插入" class="headerlink" title="4、先删除再插入"></a>4、先删除再插入</h2><p>特别是在删除找不到记录导致加Gap锁的前提下，由于Gap锁之间互相兼容，可以同时持有，容易造成插入意向锁循环等待。</p><ul><li>delete加Gap锁，兼容同时持有</li><li>insert加插入意向锁，循环等待</li></ul><table><thead><tr><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>delete from user where id=10;</td><td></td></tr><tr><td></td><td>delete from user where id=11;</td></tr><tr><td>insert into user values(10, ‘Ten’);</td><td></td></tr><tr><td></td><td>insert into user values(11, ‘Eleven’);</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/hbiboluo/mysql-deadlocks" target="_blank" rel="noopener">一些deadlock事例及说明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论&lt;code&gt;InnoDB&lt;/code&gt;引擎。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2019/01/06/avoid-mysql-deadlock-1/&quot;&gt;如何避免MySQL死锁（一）- 引子&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="https://www.hbiboluo.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="https://www.hbiboluo.com/tags/MySQL/"/>
    
      <category term="死锁" scheme="https://www.hbiboluo.com/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>如何避免MySQL死锁（四）- 阅读死锁日志</title>
    <link href="https://www.hbiboluo.com/2019/01/08/avoid-mysql-deadlock-4/"/>
    <id>https://www.hbiboluo.com/2019/01/08/avoid-mysql-deadlock-4/</id>
    <published>2019-01-08T15:00:00.000Z</published>
    <updated>2019-01-13T05:10:20.428Z</updated>
    
    <content type="html"><![CDATA[<p>注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论<code>InnoDB</code>引擎。</p><ol><li><a href="/2019/01/06/avoid-mysql-deadlock-1/">如何避免MySQL死锁（一）- 引子</a></li><li><a href="/2019/01/06/avoid-mysql-deadlock-2/">如何避免MySQL死锁（二）- MySQL锁</a></li><li><a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a></li><li><a href="/2019/01/08/avoid-mysql-deadlock-4/">如何避免MySQL死锁（四）- 阅读死锁日志</a></li><li><a href="/2019/01/11/avoid-mysql-deadlock-5/">如何避免MySQL死锁（五）- 实例分析</a></li></ol><hr><h1 id="死锁日志"><a href="#死锁日志" class="headerlink" title="死锁日志"></a>死锁日志</h1><p>死锁剧本，默认<code>RR</code>级别：</p><table><thead><tr><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>update user set name=’A’ where id=1;</td><td></td></tr><tr><td></td><td>update user set name=’B’ where id=2;</td></tr><tr><td>update user set name=’B’ where id=2;</td><td></td></tr><tr><td></td><td>update user set name=’A’ where id=1;</td></tr></tbody></table><p>查看日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br></pre></td></tr></table></figure></p><p>日志如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2019-01-08 23:34:39 0x70000e32b000</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 1017613, ACTIVE 35 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 4, OS thread handle 123145539956736, query id 261 localhost 127.0.0.1 root updating</span><br><span class="line">update user set name=&apos;B&apos; where id=2</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017613 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 00000002; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000f870e; asc       ;;</span><br><span class="line"> 2: len 7; hex 2b000005eb1da8; asc +      ;;</span><br><span class="line"> 3: len 1; hex 42; asc B;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 1017614, ACTIVE 21 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 7, OS thread handle 123145540513792, query id 262 localhost 127.0.0.1 root updating</span><br><span class="line">update user set name=&apos;A&apos; where id=1</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017614 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 00000002; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000f870e; asc       ;;</span><br><span class="line"> 2: len 7; hex 2b000005eb1da8; asc +      ;;</span><br><span class="line"> 3: len 1; hex 42; asc B;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017614 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 00000001; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000f870d; asc       ;;</span><br><span class="line"> 2: len 7; hex 2a00000620080a; asc *      ;;</span><br><span class="line"> 3: len 1; hex 41; asc A;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure></p><h1 id="日志解析"><a href="#日志解析" class="headerlink" title="日志解析"></a>日志解析</h1><h2 id="Transaction段"><a href="#Transaction段" class="headerlink" title="Transaction段"></a>Transaction段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TRANSACTION 1017613, ACTIVE 35 sec starting index read</span><br><span class="line">  解析：事务ID + 事务状态</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">  解析：操作表计数 - 使用数，锁定数</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1</span><br><span class="line">  解析：(执行状态 LOCK WAIT)，重点关注：</span><br><span class="line">  - &quot;%lu row lock(s)&quot;: 持有多少行锁，通过遍历lock structs获得计数（特别注意：包含了waiting状态的锁）</span><br><span class="line">  - &quot;undo log entries %lu&quot;: 共有多少个undo日志，更新了多少行，会影响死锁的事务牺牲判定。</span><br><span class="line">MySQL thread id 4, OS thread handle 123145539956736, query id 261 localhost 127.0.0.1 root updating</span><br><span class="line">  解析：线程信息，query id以及客户端、用户信息等</span><br><span class="line">update user set name=&apos;B&apos; where id=2</span><br><span class="line">  解析：当前query语句</span><br></pre></td></tr></table></figure><h2 id="Lock段"><a href="#Lock段" class="headerlink" title="Lock段"></a>Lock段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017613 lock_mode X locks rec but not gap waiting</span><br><span class="line">  解析：Lock的页信息，索引、加锁的类型、是否waiting</span><br><span class="line">  - lock_mode X：NK锁</span><br><span class="line">  - lock_mode X locks rec but not gap: REC锁</span><br><span class="line">  - lock_mode X locks gap before rec：Gap锁</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 00000002; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000f870e; asc       ;;</span><br><span class="line"> 2: len 7; hex 2b000005eb1da8; asc +      ;;</span><br><span class="line"> 3: len 1; hex 42; asc B;;</span><br><span class="line">   解析：锁的具体信息</span><br></pre></td></tr></table></figure><h3 id="附：锁结构-loc-rec-t"><a href="#附：锁结构-loc-rec-t" class="headerlink" title="附：锁结构 - loc_rec_t:"></a>附：锁结构 - <code>loc_rec_t</code>:</h3><p>以下内容，与InnoDB的事务、锁的内部结构有关。</p><p><code>loc_rec_t</code>是具体存放加锁信息的结构：</p><ul><li>space、page_no：指定页（InnoDB存储的最小单元，一页中多行数据以链表方式按索引顺序连接）</li><li>bitmap：行锁位信息，大小是 <strong>记录数+64</strong>；(可在批量更新时，节约创建锁的空间；)</li><li>heap：bitmap的下标对应于相应行，值为1，即加锁；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论&lt;code&gt;InnoDB&lt;/code&gt;引擎。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2019/01/06/avoid-mysql-deadlock-1/&quot;&gt;如何避免MySQL死锁（一）- 引子&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="https://www.hbiboluo.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="https://www.hbiboluo.com/tags/MySQL/"/>
    
      <category term="死锁" scheme="https://www.hbiboluo.com/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="运维" scheme="https://www.hbiboluo.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>如何避免MySQL死锁（三）- SQL语句与锁</title>
    <link href="https://www.hbiboluo.com/2019/01/07/avoid-mysql-deadlock-3/"/>
    <id>https://www.hbiboluo.com/2019/01/07/avoid-mysql-deadlock-3/</id>
    <published>2019-01-07T15:00:00.000Z</published>
    <updated>2019-01-13T05:10:06.232Z</updated>
    
    <content type="html"><![CDATA[<p>注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论<code>InnoDB</code>引擎。</p><ol><li><a href="/2019/01/06/avoid-mysql-deadlock-1/">如何避免MySQL死锁（一）- 引子</a></li><li><a href="/2019/01/06/avoid-mysql-deadlock-2/">如何避免MySQL死锁（二）- MySQL锁</a></li><li><a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a></li><li><a href="/2019/01/08/avoid-mysql-deadlock-4/">如何避免MySQL死锁（四）- 阅读死锁日志</a></li><li><a href="/2019/01/11/avoid-mysql-deadlock-5/">如何避免MySQL死锁（五）- 实例分析</a></li></ol><hr><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h2><p>将事务分解成加锁和解锁两个阶段：</p><ol><li>加锁<br>该阶段可以进行加锁操作，在对任何数据进行读操作之前要申请并获得S锁；而在进行写操作之前，需要申请X锁。加锁不成功则进入等待状态，而不能再加其它锁。</li><li>解锁<br>事务进入解锁阶段将释放其持有的锁，该阶段只能进行解锁操作，而不能再加其它锁。</li></ol><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>事务实现了不同的隔离级别，如下：</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>是</td><td>是</td><td>是</td></tr><tr><td>Read Committed</td><td>-</td><td>是</td><td>是</td></tr><tr><td>Repeatable Read</td><td>-</td><td>-</td><td>是</td></tr><tr><td>Serializable</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>问题解释如下：</p><ul><li>脏读：一个事务处理过程里读取了另一个未提交的事务中的数据。</li><li>不可重复读：对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li><li>幻读：主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。</li></ul><p>特别的，<code>RR</code>可重复读的级别可以部分解决幻读问题：</p><ul><li><code>快照读</code>使用了MVCC, 所以也就避免了部分幻读的出现！「读取后被删除，重新插入之类」</li><li><code>当前读</code>使用了Gap锁，解决幻读。</li></ul><p>但是<code>RR</code>无法解决如下情况的幻读：</p><table><thead><tr><th>事务一</th><th>事务二</th></tr></thead><tbody><tr><td>begin</td><td>begin</td></tr><tr><td>select * from demo;</td><td></td></tr><tr><td></td><td>insert into demo(id) values(1);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from demo;</td><td></td></tr><tr><td>insert into demo(id) values(1);</td><td></td></tr><tr><td>查询不到id为1的记录，插入却报错</td><td>-</td></tr></tbody></table><h1 id="SQL语句加锁"><a href="#SQL语句加锁" class="headerlink" title="SQL语句加锁"></a>SQL语句加锁</h1><h2 id="1-Consistent-Reads-–-一致性读、快照读"><a href="#1-Consistent-Reads-–-一致性读、快照读" class="headerlink" title="1. Consistent Reads – 一致性读、快照读"></a>1. Consistent Reads – 一致性读、快照读</h2><ul><li>select … from<ul><li>(<strong>非SERIALIZABLE</strong>) 快照读，不加锁</li><li>(<strong>SERIALIZABLE</strong>) 加锁</li></ul></li></ul><h2 id="2-Locking-Reads-–-当前读"><a href="#2-Locking-Reads-–-当前读" class="headerlink" title="2. Locking Reads – 当前读"></a>2. Locking Reads – 当前读</h2><ul><li>delete语句(<strong>RC</strong>情况下没有GAP锁)<ul><li>不存在，GAP锁</li><li>记录存在有删除标记，NK锁</li><li>记录存在<ul><li>非唯一索引：NK锁</li><li>唯一索引：REC锁</li></ul></li></ul></li><li>update同delete</li><li>insert语句<ul><li>插入意向锁(特殊的GAP锁)</li><li>特别的唯一键：要先做唯一键校验 - NK共享锁</li></ul></li></ul><h1 id="影响要素"><a href="#影响要素" class="headerlink" title="影响要素"></a>影响要素</h1><p>SQL语句如何加锁主要受以下两个关键要素的影响：</p><ul><li>事务隔离级别<ul><li><strong>RR</strong>:<ul><li>针对幻读问题，加NK锁</li><li>如果是能命中的<code>等值查询</code>，聚簇索引和唯一索引只加REC锁</li></ul></li><li><strong>RC</strong>:<ul><li>一般不加Gap锁</li></ul></li></ul></li><li>索引(InnoDB的行级锁锁的是索引)：查询是否走索引？什么类型的索引<ul><li><strong>正常情况下，如果查询使用的是辅助索引，会同时在满足条件的聚簇索引项上加上REC锁。</strong></li></ul></li></ul><h1 id="SQL操作的执行流程"><a href="#SQL操作的执行流程" class="headerlink" title="SQL操作的执行流程"></a>SQL操作的执行流程</h1><p><strong>InnoDB与MySQL是逐条交互，逐条加锁</strong>:</p><ul><li>根据where条件，读取第一条满足条件的记录；</li><li>返回并加锁，<code>Current Read</code>；</li><li>加锁后发起update/delete之类的操作<ul><li>insert操作可能会触发Unique Key的冲突检查，也会进行<code>Current Read</code>;</li></ul></li><li>成功后，再读取下一条，直到没有满足的记录。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html" target="_blank" rel="noopener">官方文档 - innodb如何加锁</a></li><li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">何登成 - MySQL加锁处理分析</a></li><li><a href="http://www.fordba.com/lock-analyse-of-delete.html" target="_blank" rel="noopener">MySQL DELETE 删除语句加锁分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论&lt;code&gt;InnoDB&lt;/code&gt;引擎。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2019/01/06/avoid-mysql-deadlock-1/&quot;&gt;如何避免MySQL死锁（一）- 引子&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="https://www.hbiboluo.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="https://www.hbiboluo.com/tags/MySQL/"/>
    
      <category term="死锁" scheme="https://www.hbiboluo.com/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="事务" scheme="https://www.hbiboluo.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何避免MySQL死锁（二）- MySQL锁</title>
    <link href="https://www.hbiboluo.com/2019/01/06/avoid-mysql-deadlock-2/"/>
    <id>https://www.hbiboluo.com/2019/01/06/avoid-mysql-deadlock-2/</id>
    <published>2019-01-06T07:00:00.000Z</published>
    <updated>2019-01-13T12:49:42.711Z</updated>
    
    <content type="html"><![CDATA[<p>注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论<code>InnoDB</code>引擎。</p><ol><li><a href="/2019/01/06/avoid-mysql-deadlock-1/">如何避免MySQL死锁（一）- 引子</a></li><li><a href="/2019/01/06/avoid-mysql-deadlock-2/">如何避免MySQL死锁（二）- MySQL锁</a></li><li><a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a></li><li><a href="/2019/01/08/avoid-mysql-deadlock-4/">如何避免MySQL死锁（四）- 阅读死锁日志</a></li><li><a href="/2019/01/11/avoid-mysql-deadlock-5/">如何避免MySQL死锁（五）- 实例分析</a></li></ol><hr><p>MySQL的锁，从性质来讲可以分为读锁、写锁；从粒度来讲可以分表锁、页锁、行锁；从细节上来讲可以分为记录锁、Gap锁、Next-Key锁、插入意向锁。</p><p>本节，我们从以下两个角度来解析：</p><ol><li>什么锁（重点在于锁的性质）</li><li>锁什么（重点在于锁的粒度）</li></ol><h1 id="1-什么锁"><a href="#1-什么锁" class="headerlink" title="1. 什么锁"></a>1. 什么锁</h1><p>采用了<a href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%86%99%E9%94%81" target="_blank" rel="noopener">读写锁</a>的设计，区别读、写操作。如下：</p><ul><li>Shared Lock(S)：共享锁，读锁。（允许多个读，写需等待。）</li><li>Exclusive Lock(X)：排他锁，写锁。（唯一许可。）</li></ul><h1 id="2-锁什么"><a href="#2-锁什么" class="headerlink" title="2. 锁什么"></a>2. 锁什么</h1><p>从锁的粒度来看，分为表锁、行锁以及介于两者之间的页锁，由于<code>InnoDB</code>只支持表锁和行锁，以下我们只讨论这两种。</p><h2 id="2-1-表锁"><a href="#2-1-表锁" class="headerlink" title="2.1 表锁"></a>2.1 表锁</h2><h3 id="2-1-1-Intention-Lock-意向锁"><a href="#2-1-1-Intention-Lock-意向锁" class="headerlink" title="2.1.1 Intention Lock - 意向锁"></a>2.1.1 Intention Lock - 意向锁</h3><p>首先要明确的是<strong>意向锁</strong>是表锁，代表了是否设置了表中的行级锁，是为了支持多种粒度锁同时存在而设计。</p><p>假设需要向一个表添加一个表级X锁：</p><ul><li>没有意向锁，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突；</li><li>有意向锁，则无需遍历，通过查询表锁之间是否互相兼容即可。</li></ul><p>意向锁表明一个事务稍后要获得针对<strong>一行记录</strong>的某种锁的对应表的表级锁，有两种：</p><ul><li>意向排它锁（简称 IX 锁）表明一个事务意图在某个表中设置某些行的 X 锁</li><li>意向共享锁（简称 IS 锁）表明一个事务意图在某个表中设置某些行的 S 锁</li></ul><p>兼容速查表如下，其中非意向的X锁和S锁为表级锁：</p><p><img src="/assets/images/mysql/intension-lock-compatible.jpg" alt="MySQL表锁兼容速查"></p><p>一言以敝之，意向锁之间必须走行锁粒度的检查才能知道是否兼容，但在表级兼容检查中都为兼容；其余情况遵循读写锁的规范即可。</p><h3 id="2-1-2-AUTO-INC-Locks-自增锁"><a href="#2-1-2-AUTO-INC-Locks-自增锁" class="headerlink" title="2.1.2 AUTO-INC Locks - 自增锁"></a>2.1.2 AUTO-INC Locks - 自增锁</h3><p>插入自增列时需要获取的表级锁。</p><h2 id="2-2-行锁"><a href="#2-2-行锁" class="headerlink" title="2.2 行锁"></a>2.2 行锁</h2><p><strong>注意：InnoDB的行锁是针对索引加锁。</strong>(InnoDB采用聚簇索引的方式构建，当没有主键时，优先找非空唯一列，如果没有，自动创建一个6字节的自增主键列。)</p><p>此处，请重点关注<strong>Gap Locks</strong>。</p><p><img src="/assets/images/mysql/row-lock.jpg" alt="行锁图示"></p><h3 id="2-2-1-Record-Locks-记录锁"><a href="#2-2-1-Record-Locks-记录锁" class="headerlink" title="2.2.1 Record Locks - 记录锁"></a>2.2.1 Record Locks - 记录锁</h3><p><code>LOCK_REC_NOT_GAP</code>，后文统称<code>REC锁</code>。</p><p>最简单的情况，只锁定单条记录。</p><h3 id="2-2-2-Gap-Locks-间隙锁"><a href="#2-2-2-Gap-Locks-间隙锁" class="headerlink" title="2.2.2 Gap Locks - 间隙锁"></a>2.2.2 Gap Locks - 间隙锁</h3><p><code>LOCK_GAP</code>，后文统称<code>GAP锁</code>。</p><p>最有意思的情况，锁定索引之间的内容。Gap锁设计的原因在于解决<a href="https://baike.baidu.com/item/%E5%B9%BB%E8%AF%BB" target="_blank" rel="noopener">幻读</a>的问题。</p><blockquote><p>关键：<strong>对于读取的范围加锁</strong>，且<strong>阻止插入操作</strong>。</p><ul><li>Gap锁不论S或X锁都可以互相兼容，可以同时持有</li><li>Gap锁只阻止插入，即插入意向锁！</li></ul></blockquote><p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-gap-locks" target="_blank" rel="noopener">MySQL官方关于Gap锁的解释</a>:</p><blockquote><p>Gap locks in InnoDB are “purely inhibitive”, which means that their only purpose is to prevent other transactions from inserting to the gap.<br>Gap locks can co-exist. A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other, and they perform the same function.</p></blockquote><p>注意：在<code>RC</code>级别下，search和index scans是不使用Gap锁的，只在外键约束和duplicate-key检查时使用。</p><h3 id="2-2-3-Next-Key锁"><a href="#2-2-3-Next-Key锁" class="headerlink" title="2.2.3 Next-Key锁"></a>2.2.3 Next-Key锁</h3><p><code>LOCK_ORDINARY</code>，后文统称<code>NK锁</code>。</p><p>REC锁 + 其之前的GAP锁的组合。如GAP锁是区间<code>(a, b)</code>，则NK锁是区间<code>(a, b]</code>。</p><h3 id="2-2-4-插入意向锁"><a href="#2-2-4-插入意向锁" class="headerlink" title="2.2.4 插入意向锁"></a>2.2.4 插入意向锁</h3><p><code>LOCK_INSERT_INTENTION</code>，后文统称<code>插入意向锁</code>。</p><p>特殊的Gap锁，在插入一行记录之前设置，找到当前插入位置的Gap加锁即可。多个事务如果不是在间隙相同的位置就不用相互等待。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%86%99%E9%94%81" target="_blank" rel="noopener">读写锁 - 维基百科</a></li><li><a href="https://baike.baidu.com/item/%E5%B9%BB%E8%AF%BB" target="_blank" rel="noopener">幻读 - 百度百科</a></li><li><a href="https://segmentfault.com/a/1190000014071758" target="_blank" rel="noopener">InnoDB 锁 — 官方文档（翻译）</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html" target="_blank" rel="noopener">InnoDB Locking - 官方文档</a></li><li><a href="https://segmentfault.com/a/1190000014133576" target="_blank" rel="noopener">MySQL InnoDB锁机制全面解析分享</a></li><li><a href="https://www.zhihu.com/question/51513268" target="_blank" rel="noopener">InnoDB的意向锁的作用？</a></li><li><a href="http://mysql.taobao.org/monthly/2017/12/02/" target="_blank" rel="noopener">Innodb 锁子系统浅析</a></li><li><a href="http://mysql.taobao.org/monthly/2016/01/01/" target="_blank" rel="noopener">InnoDB 事务锁系统简介</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论&lt;code&gt;InnoDB&lt;/code&gt;引擎。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2019/01/06/avoid-mysql-deadlock-1/&quot;&gt;如何避免MySQL死锁（一）- 引子&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="https://www.hbiboluo.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="https://www.hbiboluo.com/tags/MySQL/"/>
    
      <category term="死锁" scheme="https://www.hbiboluo.com/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="锁" scheme="https://www.hbiboluo.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>如何避免MySQL死锁（一）- 引子</title>
    <link href="https://www.hbiboluo.com/2019/01/06/avoid-mysql-deadlock-1/"/>
    <id>https://www.hbiboluo.com/2019/01/06/avoid-mysql-deadlock-1/</id>
    <published>2019-01-06T04:00:00.000Z</published>
    <updated>2019-01-13T03:56:56.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>事情是这样开始的……</p><p>这两天，好友L同学接到新需求，通宵达旦，终于在deadline前顺利上线了。松口气一块约了个饭，话还没聊半晌，leader却来电话了，线上MySQL并发死锁，DBA把日志都发过来了，务必赶紧解决，饭未毕人已凉……</p><p>那如何避免出现MySQL死锁问题呢？于是萌生了写一个系列文章，查缺补漏的同时也总结一下对于MySQL死锁问题的理解。</p><h1 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h1><p>死锁是在并发场景下产生的，经典的「哲学家就餐问题」很好地抽象了并发过程中的资源竞争情况。</p><p>它可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。每两个哲学家之间有一只筷子。而他们只能使用自己左右手边的那两只筷子。<br><img src="/assets/images/mysql/philosopher.jpg" alt="哲学家就餐问题"></p><p>那么这个模型下的并发问题可以这样描述：</p><ul><li>死锁：每个哲学家都同时拿起左手的筷子，等待另一边的筷子</li><li>活锁：每个哲学家都同时拿起左手的筷子，然后发现拿不到另一边的筷子，于是都放下已拿起的筷子，周而复始……</li><li>饥饿：某个哲学家拿到两边的筷子之后，一直不放回，那他两边的哲学家就会一直处于饥饿状态</li></ul><p>死锁问题可以抽象为一个有向图，节点为线程/事务，有向边表示资源/锁的依赖或者等待关系，当图中出现环时，死锁即出现。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这个系列文章的思路是这样的设计的：</p><ol><li><a href="/2019/01/06/avoid-mysql-deadlock-1/">如何避免MySQL死锁（一）- 引子</a></li><li><a href="/2019/01/06/avoid-mysql-deadlock-2/">如何避免MySQL死锁（二）- MySQL锁</a>：首先得了解竞争的到底是什么？本节，我们将要介绍MySQL的锁的分类、级别。</li><li><a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a>：了解了锁之后，就需要进一步了解不同SQL语句的加锁策略是怎么样的，才能知道发生了什么</li><li><a href="/2019/01/08/avoid-mysql-deadlock-4/">如何避免MySQL死锁（四）- 阅读死锁日志</a>：出了死锁问题，DBA把日志发过来了，那如何读懂死锁日志呢？</li><li><a href="/2019/01/11/avoid-mysql-deadlock-5/">如何避免MySQL死锁（五）- 实例分析</a>：实例分析、总结</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">哲学家就餐问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;事情是这样开始的……&lt;/p&gt;
&lt;p&gt;这两天，好友L同学接到新需求，通宵达旦，终于在deadline前顺利上线了。松口气一块约了个饭，话还没聊
      
    
    </summary>
    
      <category term="技术" scheme="https://www.hbiboluo.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="https://www.hbiboluo.com/tags/MySQL/"/>
    
      <category term="死锁" scheme="https://www.hbiboluo.com/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="哲学家就餐" scheme="https://www.hbiboluo.com/tags/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90/"/>
    
  </entry>
  
  <entry>
    <title>程序猿利器推荐</title>
    <link href="https://www.hbiboluo.com/2018/12/15/productivity/"/>
    <id>https://www.hbiboluo.com/2018/12/15/productivity/</id>
    <published>2018-12-14T16:00:00.000Z</published>
    <updated>2019-01-05T17:05:34.472Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/images/production.jpg" alt="效率工具"></p><p>工欲善其事，必先利其器，推荐一些自己常用的工具。</p><h1 id="程序猿"><a href="#程序猿" class="headerlink" title="程序猿"></a>程序猿</h1><ul><li><strong>5星</strong> Shadowsocks: 科学上网 </li><li><strong>5星</strong> Spacemacs: Vim + Emacs</li><li><strong>5星</strong> Dash「Mac Only」: 查阅API文档必备，结合<code>Alfred</code>食用效果更佳</li><li><strong>5星</strong> Proxifier「Mac Only」: 应用即使没有Proxy设置依然可以科学上网</li><li><strong>5星</strong> JupyterLab: Python必备</li><li><strong>5星</strong> Tampermonkey: Chrome插件，Hack网页必备</li><li><strong>5星</strong> Intellij IDEA: Java IDE</li></ul><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><ul><li><strong>5星</strong> iTerm「Mac Only」: Mac下很爽的终端程序</li><li><strong>5星</strong> oh-my-zsh: 终端增强，自动补全……</li><li><strong>5星</strong> htop: 服务器进程管理小能手</li><li><strong>5星</strong> tmux: 结合<code>oh-my-zsh</code>的插件，<code>ta</code>直接<code>attach</code>到指定会话</li><li><strong>5星</strong> mosh: 长时间连接server必备，断线自动恢复</li><li><strong>5星</strong> tldr: 指令的快速查询手册，Too Long Don’t Read</li><li><strong>4星</strong> mycli: 终端MySQL客户端，带Tab补全功能</li></ul><h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><ul><li><strong>5星</strong> Alfred: 强力推荐</li><li><strong>5星</strong> Pomodoro Time: 番茄工作法工具，可追踪每日各任务所用的番茄数</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><strong>6星</strong> <strong>Anki</strong>: 记忆工具，强烈推荐，可多平台同步使用！！！</li><li><strong>5星</strong> 网易云音乐</li><li><strong>5星</strong> 脑图工具：MindNode、XMind、FreeMind</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/images/production.jpg&quot; alt=&quot;效率工具&quot;&gt;&lt;/p&gt;
&lt;p&gt;工欲善其事，必先利其器，推荐一些自己常用的工具。&lt;/p&gt;
&lt;h1 id=&quot;程序猿&quot;&gt;&lt;a href=&quot;#程序猿&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="其他" scheme="https://www.hbiboluo.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="效率" scheme="https://www.hbiboluo.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="工具" scheme="https://www.hbiboluo.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
