<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>逆水行舟</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.hbiboluo.com/"/>
  <updated>2018-10-24T09:43:12.834Z</updated>
  <id>http://www.hbiboluo.com/</id>
  
  <author>
    <name>hbiboluo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序猿Mac、Linux工具推荐</title>
    <link href="http://www.hbiboluo.com/2018/01/05/productivity/"/>
    <id>http://www.hbiboluo.com/2018/01/05/productivity/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-10-24T09:43:12.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序猿"><a href="#程序猿" class="headerlink" title="程序猿"></a>程序猿</h1><ul><li><strong>5星</strong> Shadowsocks: 科学上网 </li><li><strong>5星</strong> Spacemacs: Vim + Emacs</li><li><strong>5星</strong> Dash「Mac Only」: 查阅API文档必备，结合<code>Alfred</code>食用效果更佳</li><li><strong>5星</strong> Proxifier「Mac Only」: 应用即使没有Proxy设置依然可以科学上网</li><li><strong>5星</strong> JupyterLab: Python必备</li><li><strong>5星</strong> Tampermonkey: Chrome插件，Hack网页必备</li></ul><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><ul><li><strong>5星</strong> iTerm「Mac Only」: Mac下很爽的终端程序</li><li><strong>5星</strong> oh-my-zsh: 终端增强，自动补全……</li><li><strong>5星</strong> htop: 服务器进程管理小能手</li><li><strong>5星</strong> tmux: 结合<code>oh-my-zsh</code>的插件，<code>ta</code>直接<code>attach</code>到指定会话</li><li><strong>5星</strong> mosh: 长时间连接server必备，断线自动恢复</li><li><strong>5星</strong> tldr: 指令的快速查询手册，Too Long Don’t Read.</li></ul><h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><ul><li><strong>5星</strong> Alfred「Mac Only」: 强力推荐</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><strong>6星</strong> <strong>Anki</strong>: 记忆工具，强烈推荐，可多平台同步使用！！！</li><li><strong>5星</strong> 网易云音乐</li><li><strong>5星</strong> <em>脑图工具：MindNode、XMind、FreeMind</em></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序猿&quot;&gt;&lt;a href=&quot;#程序猿&quot; class=&quot;headerlink&quot; title=&quot;程序猿&quot;&gt;&lt;/a&gt;程序猿&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;5星&lt;/strong&gt; Shadowsocks: 科学上网 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5星&lt;/
      
    
    </summary>
    
      <category term="其他" scheme="http://www.hbiboluo.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="效率" scheme="http://www.hbiboluo.com/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>Xposed快速指南</title>
    <link href="http://www.hbiboluo.com/2017/08/10/quick-start-xposed/"/>
    <id>http://www.hbiboluo.com/2017/08/10/quick-start-xposed/</id>
    <published>2017-08-09T16:00:00.000Z</published>
    <updated>2018-10-24T09:27:23.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xposed是什么"><a href="#Xposed是什么" class="headerlink" title="Xposed是什么"></a>Xposed是什么</h1><p><a href="https://github.com/rovo89/XposedBridge/wiki" target="_blank" rel="noopener">Xposed</a>是一个动态修改Android运行时的框架。</p><p>“Zygote”进程「Android运行时核心」是在手机启动时由/init.rc脚本启动，由/system/bin/app_process加载所有classes并调用初始化方法。</p><p>而Xposed框架被安装后，一个扩展的<code>app_process</code>会被安装到/system/bin/目录，将添加额外的jar包<code>/data/data/de.robv.android.xposed.installer/bin/XposedBridge.jar</code>到classpath并在指定位置调用方法。<code>XposedBridge</code>进入了类加载的世界，就可以主宰VM了。</p><p><code>XposedBridge</code>中的<code>hookMethodNative</code>方法是Xposed入口，调用<code>handleHookedMethod</code>处理具体逻辑，传递method信息，可以回调注册过该method的hook方法，对参数进行修改，修改运行结果等等。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul><li>开发环境: Android Studio</li></ul><h1 id="Xposed-API精要"><a href="#Xposed-API精要" class="headerlink" title="Xposed API精要"></a>Xposed API精要</h1><p><code>de.robv.android.xposed</code>包下的hook入口：</p><ul><li><code>IXposedHookZygoteInit</code>: Zygote进程初始化Hook，一般Android启动时使用。 </li><li><code>IXposedHookLoadPackage</code>: 应用(Package)加载Hook，一般用于Hook特定应用的一些方法。</li><li><code>IXposedHookInitPackageResources</code>: 当应用加载资源时的Hook. </li></ul><p>而重要的一些方法都在<code>de.robv.android.xposed.XposedHelpers</code>类中，比如提供的<code>findAndHookMethod</code>可以hook方法，其中参数类型：</p><ul><li>Class全限定名</li><li>ClassLoader</li><li>方法名称</li><li>可变长的方法参数类型(class/class全限定名称string)</li><li>Hook逻辑<ul><li><code>de.robv.android.xposed.XC_MethodHook</code>为before/after的hook.</li><li><code>de.robv.android.xposed.XC_MethodReplacement</code>为方法替换hook，可以通过<code>returnConstant</code>方法返回结果，或者使用<code>replaceHookedMethod</code>直接修改。</li></ul></li></ul><p>其中，被Hook的方法参数:</p><ul><li><code>de.robv.android.xposed.XC_MethodHook.MethodHookParam</code> <ul><li><code>setResult</code>和<code>setThrowable</code>方法可以修改返回值，<strong>注意当在before hook执行则跳过执行原方法</strong>。</li><li><code>thisObject</code>可以获得当前对象</li></ul></li></ul><h1 id="Xposed快速开发流程"><a href="#Xposed快速开发流程" class="headerlink" title="Xposed快速开发流程"></a>Xposed快速开发流程</h1><h2 id="第一步：添加Xposed依赖"><a href="#第一步：添加Xposed依赖" class="headerlink" title="第一步：添加Xposed依赖"></a>第一步：添加Xposed依赖</h2><p>已被发布到<a href="https://bintray.com/rovo89/de.robv.android.xposed/api" target="_blank" rel="noopener"><code>Bintray/jCenter</code></a>中, 直接添加一个Gradle dependency即可。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    provided <span class="string">'de.robv.android.xposed:api:82'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="第二步-在AndroidManifest-xml添加Xposed模块声明"><a href="#第二步-在AndroidManifest-xml添加Xposed模块声明" class="headerlink" title="第二步: 在AndroidManifest.xml添加Xposed模块声明"></a>第二步: 在AndroidManifest.xml添加Xposed模块声明</h2><p>如下，比较简单，不展开解析：）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"de.robv.android.xposed.mods.tutorial"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionCode</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionName</span>=<span class="string">"1.0"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">"15"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"xposedmodule"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"xposeddescription"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"Easy example which makes the status bar clock red and adds a smiley"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"xposedminversion"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"53"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第三步：编写Xposed-Module代码逻辑"><a href="#第三步：编写Xposed-Module代码逻辑" class="headerlink" title="第三步：编写Xposed Module代码逻辑"></a>第三步：编写Xposed Module代码逻辑</h2><h3 id="1-了解你需要hook的对象"><a href="#1-了解你需要hook的对象" class="headerlink" title="1. 了解你需要hook的对象"></a>1. <strong>了解你需要hook的对象</strong></h3><p>这一步才是真正考验的地方，如果能拿到源码就直接阅读源码吧，以下只讨论通过apk逆向工程的情况。以下步骤可跳着看:)</p><h4 id="获取应用的package-name"><a href="#获取应用的package-name" class="headerlink" title="获取应用的package name"></a>获取应用的package name</h4><p>以下两个方案是从目前运行的app中获取，如果你已经获取了apk，也可以查看AndroidManifest.xml获得：</p><p>方法一：通过adb shell的package manager获取所有package，方便但是仍然得猜<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list package</span><br></pre></td></tr></table></figure></p><p>方法二：打开应用后通过adb shell的dumpsys获得当前系统服务数据。请参考文末的参考文档了解具体用法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过window服务</span></span><br><span class="line">adb shell dumpsys window w | grep mCurrentFocus</span><br><span class="line"><span class="comment"># 或者通过activity服务</span></span><br><span class="line">adb shell dumpsys activity | grep -A 5 <span class="string">"Stack #1:"</span> | grep Intent</span><br></pre></td></tr></table></figure></p><h4 id="获取应用的apk包，以便反编译"><a href="#获取应用的apk包，以便反编译" class="headerlink" title="获取应用的apk包，以便反编译"></a>获取应用的apk包，以便反编译</h4><p>这个途径也比较多，直接从应用商店下载也是不错的选项，如果不方便下载的，直接通过pm的<code>list package -f</code>查看，再通过<code>pull</code>从手机端同步apk到PC端。示例，假设我们要获取小米应用商店的apk包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list package -f | grep com.xiaomi.market</span><br><span class="line">adb pull /system/app/MiuiSuperMarket/MiuiSuperMarket.apk ~/Downloads/</span><br></pre></td></tr></table></figure><h4 id="反编译apk查看代码理解-略"><a href="#反编译apk查看代码理解-略" class="headerlink" title="反编译apk查看代码理解(略)"></a>反编译apk查看代码理解(略)</h4><p>这一块内容比较杂，可以google一下，mac用户可以使用<a href="https://github.com/Jermic/Android-Crack-Tool" target="_blank" rel="noopener">Android Crack Tool</a>进行反编译。</p><p><img src="https://raw.githubusercontent.com/Jermic/Android-Crack-Tool/master/g1.gif" alt="Android Crack Tool截图"></p><h4 id="阅读反编译后的代码，理解关键逻辑，制定Hook方案"><a href="#阅读反编译后的代码，理解关键逻辑，制定Hook方案" class="headerlink" title="阅读反编译后的代码，理解关键逻辑，制定Hook方案"></a>阅读反编译后的代码，理解关键逻辑，制定Hook方案</h4><p><strong>TODO</strong></p><h3 id="2-编写Hook代码"><a href="#2-编写Hook代码" class="headerlink" title="2. 编写Hook代码"></a>2. 编写Hook代码</h3><p><strong>TODO</strong></p><h2 id="第四步：编写assets-xposed-init，注册Module类"><a href="#第四步：编写assets-xposed-init，注册Module类" class="headerlink" title="第四步：编写assets/xposed_init，注册Module类"></a>第四步：编写assets/xposed_init，注册Module类</h2><p>以便xposed framework了解，每行一个全限定类名即可</p><h2 id="第五步：打包安装，在Framework中启用Module并设置后重启即可"><a href="#第五步：打包安装，在Framework中启用Module并设置后重启即可" class="headerlink" title="第五步：打包安装，在Framework中启用Module并设置后重启即可"></a>第五步：打包安装，在Framework中启用Module并设置后重启即可</h2><p><strong>TODO</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/rovo89/XposedBridge/wiki/Development-tutorial" target="_blank" rel="noopener">官方Wiki</a></li><li><a href="http://api.xposed.info/reference/packages.html" target="_blank" rel="noopener">API参考文档</a></li><li><a href="https://developer.android.com/studio/command-line/dumpsys.html" target="_blank" rel="noopener">dumpsys的用法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Xposed是什么&quot;&gt;&lt;a href=&quot;#Xposed是什么&quot; class=&quot;headerlink&quot; title=&quot;Xposed是什么&quot;&gt;&lt;/a&gt;Xposed是什么&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rovo89/XposedB
      
    
    </summary>
    
      <category term="技术" scheme="http://www.hbiboluo.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="快速指南" scheme="http://www.hbiboluo.com/tags/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97/"/>
    
      <category term="Android" scheme="http://www.hbiboluo.com/tags/Android/"/>
    
      <category term="Xposed" scheme="http://www.hbiboluo.com/tags/Xposed/"/>
    
  </entry>
  
  <entry>
    <title>关于闭包</title>
    <link href="http://www.hbiboluo.com/2015/01/10/closure/"/>
    <id>http://www.hbiboluo.com/2015/01/10/closure/</id>
    <published>2015-01-09T16:00:00.000Z</published>
    <updated>2018-10-24T09:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/zh/%E9%97%AD%E5%8C%85_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29" target="_blank" rel="noopener">维基百科之闭包</a></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_counter</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span> <span class="comment"># counter() is a closure</span></span><br><span class="line">        <span class="keyword">nonlocal</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line">c1 = make_counter()</span><br><span class="line">c2 = make_counter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (c1(), c1(), c2(), c2())</span><br><span class="line"><span class="comment"># -&gt; 1 2 1 2</span></span><br></pre></td></tr></table></figure><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>闭包Closure是词法闭包的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</p><p>另一种说法，闭包是由函数和及相关的引用环境组合而成的实体。</p><ul><li>闭包在运行时可以有多个实例；</li><li>不同的引用环境和相同的函数组合可以产生不同的实例</li></ul><h3 id="某些语言表现上"><a href="#某些语言表现上" class="headerlink" title="某些语言表现上"></a>某些语言表现上</h3><p>在函数中定义另一个函数，如果内部函数引用了外部函数的变量，则可能产生闭包。一旦外部函数被执行，一个闭包就形成。体现为：闭包中包含了内部函数的代码，以及所需的外部函数中的变量引用。</p><p>这里，所引用的变量称作上值(upvalue)。</p><p>典型的支持闭包的语言中，通常将函数当作第一类对象。（函数可以当作参数传递、可以作为返回值、可以绑定到变量名）</p><h3 id="关键：上值-upvalue"><a href="#关键：上值-upvalue" class="headerlink" title="关键：上值(upvalue)"></a>关键：上值(upvalue)</h3><ul><li>在给定函数调用的过程中，能够保持其持久性；</li><li>作用域仅限于包含它们的函数，无法从其他程序代码部分进行访问；</li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>因为闭包只有在被调用时才执行操作（“惰性求值”）；</li><li>多个函数可以使用一个相同的环境，通过改变环境可以相互交流；</li><li>信息隐藏（环境）；</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>最直接的想法应该是定义一个特殊的数据结构，保存函数指针 &amp; 非local变量的指针。</p><p>而使用函数调用栈的就比较困难了，因为外部函数在返回时出栈，依赖GC机制可以把外部函数的变量(闭包的非local变量)留存起来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh/%E9%97%AD%E5%8C%85_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="技术" scheme="http://www.hbiboluo.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="http://www.hbiboluo.com/tags/Python/"/>
    
      <category term="JS" scheme="http://www.hbiboluo.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>在压力下思考</title>
    <link href="http://www.hbiboluo.com/2014/03/07/thinking-in-pressure/"/>
    <id>http://www.hbiboluo.com/2014/03/07/thinking-in-pressure/</id>
    <published>2014-03-06T16:00:00.000Z</published>
    <updated>2018-10-24T10:03:53.916Z</updated>
    
    <content type="html"><![CDATA[<p>今天参加了厂里组织的《全面管理你的工作压力》课程，本只想转换注意力借培训放松一下，不想却有很多感触，遂提笔记录。</p><p>我认为这是一次对我个人来说很精彩的培训，其实也并不是说它给你灌输新知识的多少，而是它们与你整理过的或者还在萌芽尚未整理的思想不谋而合。甚是愉悦~</p><h3 id="AHA-Moment"><a href="#AHA-Moment" class="headerlink" title="AHA Moment"></a>AHA Moment</h3><h5 id="Moment-1-情绪ABC理论"><a href="#Moment-1-情绪ABC理论" class="headerlink" title="Moment 1. 情绪ABC理论"></a>Moment 1. 情绪ABC理论</h5><p>情绪 ABC理论中：A表示诱发性事件，B表示个体针对此诱发性事件产生的一些信念，即对这件事的一些看法、解释。C表示自己产生的情绪和行为的结果。</p><p>而通常人们会认为诱发事件A直接导致了人的情绪和行为结果C，发生了什么事就引起了什么情绪体验。然而，对不同的人，相同的事情会引起不同的情绪体验。</p><p>在此理论中，我们要调整和优化的就是B我们的信念。更多内容请google词条”情绪ABC理论”</p><h5 id="Moment-2-潜在压力"><a href="#Moment-2-潜在压力" class="headerlink" title="Moment 2. 潜在压力"></a>Moment 2. 潜在压力</h5><p>而在我们的生活中其实有很多潜在的压力，来自于一些曾计划要做或想做或未完成的事，它们慢慢在我们记忆的角落里积灰，偶尔才让我们想起却不愿意去触碰。但是他们永远占用我们记忆的角落。</p><p>像我们收拾屋子一样，也是时候收拾一下我们的硬盘了。List them，直面我们潜在的压力然后各个击破他们。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>情绪ABC理论其实不只限于情绪，个人认为至少我这个个体，在发生一些活动时，也经常是A-&gt;C这个过程模式，旧的思维惯性引导着我们直接由因导果，确实提高了我们的处理效率，但是同时略显简单粗暴。</p><p>比较喜欢思考，走路、吃饭甚或睡眠，思考范围或小或大。在我的思维里，大道至简，殊途同归，有时候也会思考一下自己的行为模式，探究其原始的驱动力，而这个特质很大程度塑造了我。而思考在这里扮演的就是ABC理论中B信念的角色，所以我在分享会上把这个理论升华为思考模型。</p><p>北京这座城市的节奏较快，很多时候我们都忙着急匆匆地往前赶，忘了思考，忘了我们的初衷。希望大家在工作、生活的过程中，偶尔可以停下来思考一下。</p><h3 id="回归压力问题"><a href="#回归压力问题" class="headerlink" title="回归压力问题"></a>回归压力问题</h3><p>我的工作角色比较杂，功能设计、代码实现、帮助文档编写、构建自动化构造平台并管理构造任务、搭建并维护产品知识库（目前为博客）、维护部门服务器、解决产品公共问题和疑难问题、解决合作伙伴及用户反馈问题、在好友圈中扮演技术救火英雄等等。当然，我热爱我所做的这些！</p><p>但伴随而来的是各种角色不断渗入我的工作时间，让我的时间支离破碎。我觉得研发这件事情是快乐的，但是需要专注。而处理这些非计划事件又让我频繁切换上下文，以至于效率下降。</p><p>而在我的生活中，微博、微信、手机等等让我在享受科技带来便利的同时，也引入了更多碎片化的时间，习惯了在班车上刷微博，最近慢慢察觉被动接受了很多对我无用的信息。于是重新回归RSS，推送到kindle让我专注于阅读。</p><p>而我处理工作压力的方法，首先是认识并承认这些压力，然后采用给时间分段，保持单位时间段内的专注性。课堂上听说了蕃茄工作法，知乎一下，亦有不谋而合之处。后续可以深入尝试一下。</p><p>目前，需要一个辅助我进行此类时间管理的工具，是否有推荐的？（我希望其一方便记录，其二支持多设备同步）Google日历？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天参加了厂里组织的《全面管理你的工作压力》课程，本只想转换注意力借培训放松一下，不想却有很多感触，遂提笔记录。&lt;/p&gt;
&lt;p&gt;我认为这是一次对我个人来说很精彩的培训，其实也并不是说它给你灌输新知识的多少，而是它们与你整理过的或者还在萌芽尚未整理的思想不谋而合。甚是愉悦~&lt;
      
    
    </summary>
    
      <category term="其他" scheme="http://www.hbiboluo.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="思考" scheme="http://www.hbiboluo.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Jekyll之道,Geek之道</title>
    <link href="http://www.hbiboluo.com/2013/04/24/dao-of-jekyll/"/>
    <id>http://www.hbiboluo.com/2013/04/24/dao-of-jekyll/</id>
    <published>2013-04-23T16:00:00.000Z</published>
    <updated>2018-10-24T10:01:52.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自由的Jekyll"><a href="#自由的Jekyll" class="headerlink" title="自由的Jekyll"></a>自由的Jekyll</h3><p>初见<code>Jekyll</code>时它是和<code>Github Pages</code>在一起的，从一开始它在我耳畔就萦绕起geek的声音三日不绝。江南三月，杨柳依依，春风拂面，<code>Jekyll</code>就此婀娜行来~</p><p>嗯，好好说话。Geek之道，在于热于探索，追求自由，<code>Jekyll</code>主要技术如<code>YAML</code>、<code>MarkDown</code>、<code>Liquid</code>都不属烂大街的东西，门槛有但都简单，在这个世界里你可以主宰所有，导航来个固定布局，主区域左右分栏，哦footer还要卖个萌，内容无论是以多媒体还是以文字为主，<code>Jekyll</code>毫无压力。</p><h3 id="自由的味道是什么？"><a href="#自由的味道是什么？" class="headerlink" title="自由的味道是什么？"></a>自由的味道是什么？</h3><h5 id="久旱逢甘霖-简洁的MarkDown语法"><a href="#久旱逢甘霖-简洁的MarkDown语法" class="headerlink" title="久旱逢甘霖 - 简洁的MarkDown语法"></a>久旱逢甘霖 - 简洁的MarkDown语法</h5><p>MarkDown的设定从最一开始就是适用于Web写作的工具，提供简洁的语法以便转换为HTML。</p><p>传统的HTML方式，把正文与tag混杂到一块，为了突出显示粗体不得不相开始和结束一个strong标签<strong></strong>，更别论引用、代码高亮之类了。Docbook虽然标准，仍属XML系统，摆脱不了编写过于繁琐的劣势。</p><h5 id="他乡遇故知-文本载体，易于版本控制"><a href="#他乡遇故知-文本载体，易于版本控制" class="headerlink" title="他乡遇故知 - 文本载体，易于版本控制"></a>他乡遇故知 - 文本载体，易于版本控制</h5><p>动态语言一般都会选择数据库来保存内容，相信CSDN、JavaEye等博客内容都是如此处理的，即使能够导出估计最后导出的格式也是百花怒放之象。</p><p>Jekyll则是通过post生成静态的HTML以供部署，原始内容是以html或MarkDown组织的正文，特别适合纳入版本控制特别是Git这种分布式的版本控制体系，尽情享用！</p><h5 id="洞房花烛夜-编辑器之殇"><a href="#洞房花烛夜-编辑器之殇" class="headerlink" title="洞房花烛夜 - 编辑器之殇"></a>洞房花烛夜 - 编辑器之殇</h5><p>想想在号称所见即所得的Web上编写博客的场景吧，不能tab，设计个列表需要在工具栏上找啊找，你想做个链接，哦，他想加个图片，这些都不是灾难性的，当你点击发布或者保存草稿时,Oh Shit! 网络异常？服务器错误？这时，你肯定会有一种欲哭无泪的绝望，可惜无能为力。</p><p>再想象一下用你最得心应手的编辑器来写博客，你可以使用由此带来的所有特性。使用vi我可以毫不费力地处理去除粘贴过来代码多余的前置空白，可以使用宏，多么美好的一天啊~</p><h5 id="金榜提名时-Github"><a href="#金榜提名时-Github" class="headerlink" title="金榜提名时 - Github"></a>金榜提名时 - Github</h5><p>毫无疑问的压轴大戏。对我这种超轻度博客作者来讲，免费再加上Github这几个字母就足够了。你可以选择把site部署到其他服务器上，所以其实Github也不算是必选项。</p><p>然后，你可以用到之前提及的所有特性来建立你的项目主页、分享你的知识，并部署到各种http容器中，纯静态的内容从性能上来讲也拉开那些动态内容几条街，唯一的缺点是静态内容是基于你的post、page在部署前生成的，所以比较适合个人和中小企业。</p><h3 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h3><ul><li><a href="https://github.com/mojombo/jekyll/wiki" target="_blank" rel="noopener">Jekyll Github Wiki</a></li><li><a href="http://jekyllbootstrap.com/" target="_blank" rel="noopener">The Quickest Way to Blog on GitHub Pages</a></li><li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown语法说明</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">搭建一个免费的，无限流量的Blog——github Pages和Jekyll入门</a></li><li><a href="https://www.google.com.hk/search?q=Jekyll&amp;aq=f&amp;oq=jekyll&amp;aqs=chrome.0.59j65j61j65l2j60.1630&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">Google “Jekyll” 更多…</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;自由的Jekyll&quot;&gt;&lt;a href=&quot;#自由的Jekyll&quot; class=&quot;headerlink&quot; title=&quot;自由的Jekyll&quot;&gt;&lt;/a&gt;自由的Jekyll&lt;/h3&gt;&lt;p&gt;初见&lt;code&gt;Jekyll&lt;/code&gt;时它是和&lt;code&gt;Github Page
      
    
    </summary>
    
      <category term="其他" scheme="http://www.hbiboluo.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="效率" scheme="http://www.hbiboluo.com/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
</feed>
