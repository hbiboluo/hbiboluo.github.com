<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>读书笔记《金字塔原理》</title>
      <link href="/2019/04/24/pyramid_principle/"/>
      <url>/2019/04/24/pyramid_principle/</url>
      
        <content type="html"><![CDATA[<h1 id="0、总述：场景-x-结构"><a href="#0、总述：场景-x-结构" class="headerlink" title="0、总述：场景 x 结构"></a>0、总述：场景 x 结构</h1><p>工作生活中处处都有着场景：表达、提问、思考、解决问题、排兵布阵……</p><p>当其内在没有一个结构来支撑时，往往让人感觉无重点、无逻辑，个人感觉本书的中心是：<strong>给场景赋予结构</strong></p><p><strong>场景 x 结构</strong>的意思是场景与结构中做迪卡尔积，不同场景更适合的结构是不同的，可以想象一个二维表，场景和结构的交叉处是其适用程度的得分。</p><p>另外，<code>结构</code>本身并不是单一结构，可以是复合的。</p><p>本书，从「金字塔」结构进行论述，并且不同的应用场景各有其不同特点。</p><h1 id="1、原理：结构-金字塔"><a href="#1、原理：结构-金字塔" class="headerlink" title="1、原理：结构 - 金字塔"></a>1、原理：结构 - 金字塔</h1><p><img src="/assets/images/pyramid_head.jpg" alt="总纲"><br>五人为伍，二伍为什。</p><h2 id="1-1-金字塔-树"><a href="#1-1-金字塔-树" class="headerlink" title="1.1 金字塔 - 树"></a>1.1 金字塔 - 树</h2><p>树结构对于各个节点延伸出了两个维度的信息：</p><ul><li>纵向<ul><li>关系<ul><li>上统下：总结概括、疑问/回答</li></ul></li></ul></li><li>横向<ul><li>关系<ul><li>同一逻辑范畴</li><li>逻辑顺序排列「时间、结构、程度」</li></ul></li><li>原则<ul><li>MECE原则「互相独立、彼此穷尽」</li></ul></li></ul></li></ul><h2 id="1-2-如何构建"><a href="#1-2-如何构建" class="headerlink" title="1.2 如何构建"></a>1.2 如何构建</h2><ul><li>自上而下</li><li>自下而上</li></ul><h1 id="2、应用：场景-表达-写作-、思考、解决问题、演示"><a href="#2、应用：场景-表达-写作-、思考、解决问题、演示" class="headerlink" title="2、应用：场景 - 表达(写作)、思考、解决问题、演示"></a>2、应用：场景 - 表达(写作)、思考、解决问题、演示</h1><h2 id="2-1-表达-amp-演示"><a href="#2-1-表达-amp-演示" class="headerlink" title="2.1 表达 &amp; 演示"></a>2.1 表达 &amp; 演示</h2><p>此处把表达以及演示合并，共同点都在于是双向过程，在于以受众（听众、读者、观众等）为中心。</p><ul><li>目标<ul><li>吸引/保持受众注意力</li><li>减少受众的接受难度</li></ul></li><li>策略<ul><li>表达：序言（背景、冲突、疑问、答案）、结论先行、</li><li>演示：写好PPT，避免视觉朗诵……</li></ul></li></ul><h2 id="2-2-思考"><a href="#2-2-思考" class="headerlink" title="2.2 思考"></a>2.2 思考</h2><p><em>避免罗列、概括各组真义。</em></p><h2 id="2-3-解决问题"><a href="#2-3-解决问题" class="headerlink" title="2.3 解决问题"></a>2.3 解决问题</h2><p>务必从问题出发：</p><ul><li>界定问题「可映射到表达里的序言」<ul><li>diff(现状, 目标)</li></ul></li><li>结构化分析 <ul><li>四步曲<ul><li>收集信息「收集发生在界定问题之后！」</li><li>描述发现</li><li>得出结论</li><li>提出方案</li></ul></li></ul></li></ul><h1 id="3、延伸"><a href="#3、延伸" class="headerlink" title="3、延伸"></a>3、延伸</h1><h2 id="3-1-结构延伸"><a href="#3-1-结构延伸" class="headerlink" title="3.1 结构延伸"></a>3.1 结构延伸</h2><ul><li>图，从结构上来说比树更自由，可完成任意节点间的关联<ul><li>结构「过于自由的模型，可以归纳为滥用反而事倍功半」<ul><li>节点</li><li>连接<ul><li>有向（单向、双向） – 更多信息</li></ul></li><li>隐式<ul><li>兄弟关系「并列」– 不如树直观</li></ul></li></ul></li><li>典型结构<ul><li>流程图</li><li>图形结构<ul><li>三角</li><li>矩形</li><li>五星</li><li>雁形</li></ul></li><li>……</li></ul></li></ul></li></ul><h2 id="3-2-应用延伸"><a href="#3-2-应用延伸" class="headerlink" title="3.2 应用延伸"></a>3.2 应用延伸</h2><ul><li>流程图应用</li><li>组织架构</li><li>……</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读书笔记《格鲁夫给经理人的第一课》</title>
      <link href="/2019/03/21/high_output_management/"/>
      <url>/2019/03/21/high_output_management/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/images/high_output_management/main.png" alt="总纲"></p><h1 id="1、产出导向管理"><a href="#1、产出导向管理" class="headerlink" title="1、产出导向管理"></a>1、产出导向管理</h1><p>以产出为导向的管理，不论是组织管理还是个人管理。特别明确作为一个经理人，其产出是：</p><blockquote><p>一个经理人的产出，便是他所管理或影响所及的部属工作的成效总和。</p></blockquote><h1 id="2、经理人"><a href="#2、经理人" class="headerlink" title="2、经理人"></a>2、经理人</h1><h2 id="2-1-核心公式"><a href="#2-1-核心公式" class="headerlink" title="2.1 核心公式"></a>2.1 核心公式</h2><blockquote><p>经理人的产出 = 组织产出的总和 = 杠杆率A×管理活动A＋杠杆率B×管理活动B……</p><p>在这个等式中，经理人所从事的每一项管理活动（管理活动A、B……）对整个组织都有或多或少的影响。而对整个产出的影响有多大，则在于这项活动的杠杆率大小。一个经理人的产出便是这些乘积的加总。显而易见，为了有较高的产出，经理人应该把精力放在杠杆率较高的活动上。</p><p>经理人的生产力亦即其每个单位时间的产出，可通过以下3种方法来增加：</p><ol><li>加快每一项活动进行的速度。</li><li>提高每一项活动的杠杆率。</li><li>调整管理活动的组合，摒除低杠杆率的活动，代之以高杠杆率的活动。</li></ol></blockquote><p><strong>大都人都知道「要事第一」的原则，而困难的事情是识别什么是「要事」，经理人的产出公式恰恰指明了如何来识别要事。</strong></p><h3 id="2-1-1-杠杆率「提升每项活动的杠杆率」"><a href="#2-1-1-杠杆率「提升每项活动的杠杆率」" class="headerlink" title="2.1.1 杠杆率「提升每项活动的杠杆率」"></a>2.1.1 杠杆率「提升每项活动的杠杆率」</h3><p>杠杆率：定义为对于产出的影响力。特别要注意，杠杆率可能为负。「个人定义：活动的产出」</p><p>确定了活动组合，不同的执行人收获的却是不同的产出，核心就在于对于每项活动，执行人带来的成果。如何提升杠杆率，避免负向作用？书中谈到高杠杆率主要是影响更多的人、产生更长远的影响。尝试抽象一下：</p><ul><li>影响面「k, 累加」：对多少人产生直接/间接的影响。</li><li>影响度「x, 每个个体不一」：对一个人产生多大的影响，正向还是负向。</li></ul><p><code>杠杆率 = Sum(Xi)</code></p><h3 id="2-1-2-成本「加快活动速度，即是减小成本投入」"><a href="#2-1-2-成本「加快活动速度，即是减小成本投入」" class="headerlink" title="2.1.2 成本「加快活动速度，即是减小成本投入」"></a>2.1.2 成本「加快活动速度，即是减小成本投入」</h3><p>在这个核心公式中，我们以杠杆率来衡量各项活动的产出，但是我们同时还需要关注投入的成本：特别是时间。</p><h3 id="2-1-3-均衡活动的投入产出比「选择活动的艺术」"><a href="#2-1-3-均衡活动的投入产出比「选择活动的艺术」" class="headerlink" title="2.1.3 均衡活动的投入产出比「选择活动的艺术」"></a>2.1.3 均衡活动的投入产出比「选择活动的艺术」</h3><p>构建一个 [成本, 产出, 产出/成本] 的三维空间，理论上可以寻找到一个 argmax(产出/成本) 的值。</p><ul><li>在同一活动的三维空间中，尽量离 max(产出/成本) 近的点</li><li>在不同活动的选择中<ul><li>尽量选择 max(产出/成本) 较高的活动 </li><li>尽量选择在限定成本内，exp(产出/成本) 较高的活动</li></ul></li></ul><h2 id="2-2-决策"><a href="#2-2-决策" class="headerlink" title="2.2 决策"></a>2.2 决策</h2><blockquote><p>我们希望决策是由离问题最近，而且最了解问题的人来制定。参考决策的制定过程，是每个经理人每日例行工作中非常重要的一环。</p></blockquote><p><img src="/assets/images/high_output_management/2.2.png" alt="理想决策过程中的三个阶段"></p><h1 id="3-连接-管理-协作"><a href="#3-连接-管理-协作" class="headerlink" title="3 连接 - 管理/协作"></a>3 连接 - 管理/协作</h1><h2 id="3-1-管理实践-认知"><a href="#3-1-管理实践-认知" class="headerlink" title="3.1 管理实践/认知"></a>3.1 管理实践/认知</h2><h3 id="3-1-1-控制模式"><a href="#3-1-1-控制模式" class="headerlink" title="3.1.1 控制模式"></a>3.1.1 控制模式</h3><p>“三个长官”：</p><ul><li>自由市场因素：个人利益</li><li>契约义务：条文约束</li><li>文化价值观：价值观。当环境变化太快、规则无法及时应对时，个人的文化价值观便决定了我们的行动。「换个最简单的说法，文化价值观就是要形成个人对于团队利益的认同，并且愿意牺牲个人利益或者短期利益。长期牺牲或者不是双赢本身就是不合理的，那样是精神控制了。」</li></ul><p>以下是书中提到的最合适的控制模式，主要受限于两个变量：1）个人关注的利益；2）CUA程度「CUA为Complexity、Uncertainty、Ambiguity」，用于衡量一个工作环境的复杂性、不确定性以及指令的模糊性。</p><table><thead><tr><th></th><th>CUA低</th><th>CUA高</th></tr></thead><tbody><tr><td>关注团队利益</td><td>契约义务</td><td>文化价值观</td></tr><tr><td>关注个人利益</td><td>自由市场因素</td><td>/</td></tr></tbody></table><h3 id="3-1-2-工作成熟度及其对应的有效领导风格"><a href="#3-1-2-工作成熟度及其对应的有效领导风格" class="headerlink" title="3.1.2 工作成熟度及其对应的有效领导风格"></a>3.1.2 工作成熟度及其对应的有效领导风格</h3><p>以下表格左侧摘自书内，是相对有效的领导风格，个人理解主要是对于放权及监督的权衡。</p><table><thead><tr><th>部属的工作成熟度</th><th>有效的领导风格</th><th>个人解读</th></tr></thead><tbody><tr><td>高</td><td>组织化，任务导向，告诉员工该做什么，何时完成以及如何着手</td><td>重任务导向</td></tr><tr><td>中</td><td>注重个体，强调双向沟通，给予情绪上的支持及鼓励。上司与下属之间相互了解。</td><td>任务导向为主，过程监督为辅</td></tr><tr><td>低</td><td>经理人的参与程度降低；彼此建立起工作目标及监督系统。</td><td>重过程监督</td></tr></tbody></table><ul><li>工作成熟度越高，对部属的干涉越低；</li><li>不论哪个成熟度，都需要监督过程，这是授权之后经理人的责任；</li><li>放权 &amp; 监督；</li></ul><h2 id="3-2-信息交换"><a href="#3-2-信息交换" class="headerlink" title="3.2 信息交换"></a>3.2 信息交换</h2><p>交办、开会……</p><p>口头、书面……</p><h3 id="3-2-1-开会"><a href="#3-2-1-开会" class="headerlink" title="3.2.1 开会"></a>3.2.1 开会</h3><blockquote><p>会议是人事管理工作必经的媒介。你绝对无法避免开会，但你能让会议更有效率。</p></blockquote><ul><li>「过程导向」会议，通常是例行的。 – 交换信息或技术<ul><li>“规律化”是提升效率最好的方法。</li></ul></li><li>「任务导向」会议，通常有决策产生。 – 解决特定问题</li></ul><h1 id="4、人员"><a href="#4、人员" class="headerlink" title="4、人员"></a>4、人员</h1><p>关注问题：</p><ul><li>意愿：激励「以马斯洛的需求层次理论为基础」</li><li>能力：培训</li></ul><p>其他：人员在职的生命周期：进 与 出。</p><h1 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h1><h2 id="5-1-双重报告"><a href="#5-1-双重报告" class="headerlink" title="5.1 双重报告"></a>5.1 双重报告</h2><p>在功能导向的组织中安置专业人员的一个最佳实践。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>拿软件开发的过程来类比经理人的行为，有一些挺有意思的收获。</p><p>经理 = 一个功能模块，负责对外输出整体能力「包含了个体与整体的双重角色，简单定义为：类 -&gt; 模块 -&gt; 系统」</p><p>下属 = 类比为工具类/提供特定职责类，主要负责内部的具体某项内容「只包含个体的角色」</p><p>这个类比模型里， 可以反馈出一些共同点：</p><ul><li>职责：需要对整个功能模块负责，包含了内部的所有类。</li><li>指派：<ul><li>当调用某个类时，需要明确接口，包含输入、输出，以及性能。「对应指派任务的目标、验收点以及deadline。」</li><li>针对不同成熟度的工程师，会给予不同层面的自由度</li></ul></li><li>实践：<ul><li>测试：验收</li><li>多线程并发控制：协作</li><li>……</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>短评《如何阅读一本书》</title>
      <link href="/2019/02/21/how_to_read_a_book/"/>
      <url>/2019/02/21/how_to_read_a_book/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/img/reading.jpg" alt="如何阅读一本书"></p><p>简单总结《如何阅读一本书》中目前个人理解的要点。</p><h1 id="主动阅读"><a href="#主动阅读" class="headerlink" title="主动阅读"></a>主动阅读</h1><h2 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h2><ul><li>书的金字塔原则：好书是有限的，知无涯而生有涯<ul><li>聚焦在少数真正有提升的书籍</li><li>花合适的成本去阅读对应书籍</li><li>有必要在限定时间内了解一本书是否值得花更多时间、精力去研习</li></ul></li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>阅读目标：学习、提升</li><li>阅读过程：从文字中理解作者想表达的的思想：主题、思路框架、主旨及论点……<ul><li>越是与目前能力有差距的书，越要付出更多的时间、精力以及理解力。</li><li>合理的期望：提升大的书，需要逐次逐步阅读。</li><li>避免口语主义：反模式是记住了原话，而没有理解真义。所以最好的方式是<strong>用自己的话来表达</strong>！</li></ul></li><li>阅读成果：阅读目标的答卷<ul><li>学以致用</li><li>知行合一，深知深行，浅知浅行，不知不行</li></ul></li></ul><h1 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h1><p>这些方法是为指导我们阅读时要达成的小目标，也是作者理想的最佳实践。</p><p>完全遵循书中的规则偏理想，可以把它们看成是否完成该层次阅读的验收标准。</p><h2 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h2><ul><li>重点：限时！</li><li>目标：了解主题、框架以及主要解决问题，以及是否有价值花更多时间做更完整的阅读。</li><li>要点：<ul><li>SOP：系统性略读</li><li>粗浅的阅读：在限定时间内，安排好时间、精力快速读完一遍<ul><li>特别是在难懂的地方不要停下来，在价值不大的地方不要做太多投入</li><li>特别要注意找到作者自己的总结，一般在首章或末章</li></ul></li></ul></li></ul><h2 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h2><p>完成以下内容：</p><ul><li>书内<ul><li>框架性 - 透视一本书</li><li>内容性 - 诠释一本书</li></ul></li><li>书外<ul><li>平等性 - 评断一本书</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何避免MySQL死锁（五）- 实例分析</title>
      <link href="/2019/01/11/avoid-mysql-deadlock-5/"/>
      <url>/2019/01/11/avoid-mysql-deadlock-5/</url>
      
        <content type="html"><![CDATA[<p>注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论<code>InnoDB</code>引擎。</p><ol><li><a href="/2019/01/06/avoid-mysql-deadlock-1/">如何避免MySQL死锁（一）- 引子</a></li><li><a href="/2019/01/06/avoid-mysql-deadlock-2/">如何避免MySQL死锁（二）- MySQL锁</a></li><li><a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a></li><li><a href="/2019/01/08/avoid-mysql-deadlock-4/">如何避免MySQL死锁（四）- 阅读死锁日志</a></li><li><a href="/2019/01/11/avoid-mysql-deadlock-5/">如何避免MySQL死锁（五）- 实例分析</a></li></ol><hr><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>新建表结构:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`U_name`</span>(<span class="string">`name`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">6</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></p><p>插入数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">'One'</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'Two'</span>),</span><br><span class="line">  (<span class="number">3</span>, <span class="string">'Three'</span>),</span><br><span class="line">  (<span class="number">5</span>, <span class="string">'Five'</span>);</span><br></pre></td></tr></table></figure></p><p>注意模拟之后，<code>rollback</code>回滚事务。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="1、加锁顺序问题"><a href="#1、加锁顺序问题" class="headerlink" title="1、加锁顺序问题"></a>1、加锁顺序问题</h2><h3 id="1-1-显式：相同索引的加锁顺序"><a href="#1-1-显式：相同索引的加锁顺序" class="headerlink" title="1.1 显式：相同索引的加锁顺序"></a>1.1 显式：相同索引的加锁顺序</h3><table><thead><tr><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>update user set name=’O’ where id=1;</td><td></td></tr><tr><td></td><td>update user set name=’T’ where id=2;</td></tr><tr><td>update user set name=’T’ where id=2;</td><td></td></tr><tr><td></td><td>update user set name=’O’ where id=1;</td></tr></tbody></table><h3 id="1-2-隐式：不同索引的加锁顺序"><a href="#1-2-隐式：不同索引的加锁顺序" class="headerlink" title="1.2 隐式：不同索引的加锁顺序"></a>1.2 隐式：不同索引的加锁顺序</h3><table><thead><tr><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>update user set name=’O’ where id=1;</td><td></td></tr><tr><td></td><td>update user set name=’T’ where name=’TWO’;</td></tr><tr><td>update user set name=’T’ where id=2;</td><td></td></tr><tr><td></td><td>update user set name=’O’ where name=’ONE’;</td></tr></tbody></table><p>走不同的索引可能会导致在聚簇索引上的不同加锁顺序，以上的示例是简单的场景，实际场景上要非常注意以下情况：</p><ul><li>即使是相同语句，不同value的查询可能也会走不同的索引，切记，具体要看日志来。走什么索引是由优化器决定。</li></ul><h2 id="2、锁升级"><a href="#2、锁升级" class="headerlink" title="2、锁升级"></a>2、锁升级</h2><p>delete标记导致的不同加锁策略，普通的等值查询加锁在<code>RR</code>事务级别下是这样的：</p><ul><li>找到满足条件的记录：加REC锁</li><li>没找到满足条件的记录：加Gap锁</li><li><strong>特别的，找到了满足条件的记录但是被标记为delete：加NK锁</strong></li></ul><p>前文<a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a>介绍了SQL语句是逐行加锁，逐行操作的。<br>高并发情况下(3个事务及其以上)，可能会出现同时申请获取delete的REC锁，事务排队后获取时发现记录已被删除，将在不释放锁的前提下重新去获取Gap锁（二阶段锁协议），如果此时另一个事务已经提前去排队取NK锁，凉凉。。。</p><h2 id="3、操作的非原子性"><a href="#3、操作的非原子性" class="headerlink" title="3、操作的非原子性"></a>3、操作的非原子性</h2><h3 id="3-1-唯一键插入的两过程"><a href="#3-1-唯一键插入的两过程" class="headerlink" title="3.1 唯一键插入的两过程"></a>3.1 唯一键插入的两过程</h3><ul><li>先进行一次唯一键的冲突检测，加 (LOCK_GAP | LOCK_REC | LOCK_S)，共享锁</li><li>然后才获取插入意向锁，加(LOCK_INSERT_INTENTION | LOCK_GAP | LOCK_X )，写锁</li></ul><table><thead><tr><th>事务1</th><th>事务2</th><th>事务3</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td><td>start transaction;</td></tr><tr><td>insert into user values(6, ‘Six’)</td><td></td><td></td></tr><tr><td></td><td>insert into user values(6, ‘Six’)</td><td></td></tr><tr><td></td><td></td><td>insert into user values(6, ‘Six’)</td></tr><tr><td>rollback;</td><td>-</td><td>-</td></tr></tbody></table><p>事务2、3同时持有共享的NK锁，插入意向锁循环等待。（除了以上示例，高并发场景下，有可能出现）</p><h3 id="3-2-删除-等值查询-的两过程"><a href="#3-2-删除-等值查询-的两过程" class="headerlink" title="3.2 删除(等值查询)的两过程"></a>3.2 删除(等值查询)的两过程</h3><ul><li>获取REC锁</li><li>标记为删除</li></ul><p>参见：「2、锁升级」</p><h2 id="4、先删除再插入"><a href="#4、先删除再插入" class="headerlink" title="4、先删除再插入"></a>4、先删除再插入</h2><p>特别是在删除找不到记录导致加Gap锁的前提下，由于Gap锁之间互相兼容，可以同时持有，容易造成插入意向锁循环等待。</p><ul><li>delete加Gap锁，兼容同时持有</li><li>insert加插入意向锁，循环等待</li></ul><table><thead><tr><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>delete from user where id=10;</td><td></td></tr><tr><td></td><td>delete from user where id=11;</td></tr><tr><td>insert into user values(10, ‘Ten’);</td><td></td></tr><tr><td></td><td>insert into user values(11, ‘Eleven’);</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/hbiboluo/mysql-deadlocks" target="_blank" rel="noopener">一些deadlock事例及说明</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 死锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何避免MySQL死锁（四）- 阅读死锁日志</title>
      <link href="/2019/01/08/avoid-mysql-deadlock-4/"/>
      <url>/2019/01/08/avoid-mysql-deadlock-4/</url>
      
        <content type="html"><![CDATA[<p>注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论<code>InnoDB</code>引擎。</p><ol><li><a href="/2019/01/06/avoid-mysql-deadlock-1/">如何避免MySQL死锁（一）- 引子</a></li><li><a href="/2019/01/06/avoid-mysql-deadlock-2/">如何避免MySQL死锁（二）- MySQL锁</a></li><li><a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a></li><li><a href="/2019/01/08/avoid-mysql-deadlock-4/">如何避免MySQL死锁（四）- 阅读死锁日志</a></li><li><a href="/2019/01/11/avoid-mysql-deadlock-5/">如何避免MySQL死锁（五）- 实例分析</a></li></ol><hr><h1 id="死锁日志"><a href="#死锁日志" class="headerlink" title="死锁日志"></a>死锁日志</h1><p>死锁剧本，默认<code>RR</code>级别：</p><table><thead><tr><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>start transaction;</td><td>start transaction;</td></tr><tr><td>update user set name=’A’ where id=1;</td><td></td></tr><tr><td></td><td>update user set name=’B’ where id=2;</td></tr><tr><td>update user set name=’B’ where id=2;</td><td></td></tr><tr><td></td><td>update user set name=’A’ where id=1;</td></tr></tbody></table><p>查看日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br></pre></td></tr></table></figure></p><p>日志如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2019-01-08 23:34:39 0x70000e32b000</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 1017613, ACTIVE 35 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 4, OS thread handle 123145539956736, query id 261 localhost 127.0.0.1 root updating</span><br><span class="line">update user set name=&apos;B&apos; where id=2</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017613 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 00000002; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000f870e; asc       ;;</span><br><span class="line"> 2: len 7; hex 2b000005eb1da8; asc +      ;;</span><br><span class="line"> 3: len 1; hex 42; asc B;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 1017614, ACTIVE 21 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 7, OS thread handle 123145540513792, query id 262 localhost 127.0.0.1 root updating</span><br><span class="line">update user set name=&apos;A&apos; where id=1</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017614 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 00000002; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000f870e; asc       ;;</span><br><span class="line"> 2: len 7; hex 2b000005eb1da8; asc +      ;;</span><br><span class="line"> 3: len 1; hex 42; asc B;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017614 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 00000001; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000f870d; asc       ;;</span><br><span class="line"> 2: len 7; hex 2a00000620080a; asc *      ;;</span><br><span class="line"> 3: len 1; hex 41; asc A;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure></p><h1 id="日志解析"><a href="#日志解析" class="headerlink" title="日志解析"></a>日志解析</h1><h2 id="Transaction段"><a href="#Transaction段" class="headerlink" title="Transaction段"></a>Transaction段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TRANSACTION 1017613, ACTIVE 35 sec starting index read</span><br><span class="line">  解析：事务ID + 事务状态</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">  解析：操作表计数 - 使用数，锁定数</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1</span><br><span class="line">  解析：(执行状态 LOCK WAIT)，重点关注：</span><br><span class="line">  - &quot;%lu row lock(s)&quot;: 持有多少行锁，通过遍历lock structs获得计数（特别注意：包含了waiting状态的锁）</span><br><span class="line">  - &quot;undo log entries %lu&quot;: 共有多少个undo日志，更新了多少行，会影响死锁的事务牺牲判定。</span><br><span class="line">MySQL thread id 4, OS thread handle 123145539956736, query id 261 localhost 127.0.0.1 root updating</span><br><span class="line">  解析：线程信息，query id以及客户端、用户信息等</span><br><span class="line">update user set name=&apos;B&apos; where id=2</span><br><span class="line">  解析：当前query语句</span><br></pre></td></tr></table></figure><h2 id="Lock段"><a href="#Lock段" class="headerlink" title="Lock段"></a>Lock段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017613 lock_mode X locks rec but not gap waiting</span><br><span class="line">  解析：Lock的页信息，索引、加锁的类型、是否waiting</span><br><span class="line">  - lock_mode X：NK锁</span><br><span class="line">  - lock_mode X locks rec but not gap: REC锁</span><br><span class="line">  - lock_mode X locks gap before rec：Gap锁</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 00000002; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000f870e; asc       ;;</span><br><span class="line"> 2: len 7; hex 2b000005eb1da8; asc +      ;;</span><br><span class="line"> 3: len 1; hex 42; asc B;;</span><br><span class="line">   解析：锁的具体信息</span><br></pre></td></tr></table></figure><h3 id="附：锁结构-loc-rec-t"><a href="#附：锁结构-loc-rec-t" class="headerlink" title="附：锁结构 - loc_rec_t:"></a>附：锁结构 - <code>loc_rec_t</code>:</h3><p>以下内容，与InnoDB的事务、锁的内部结构有关。</p><p><code>loc_rec_t</code>是具体存放加锁信息的结构：</p><ul><li>space、page_no：指定页（InnoDB存储的最小单元，一页中多行数据以链表方式按索引顺序连接）</li><li>bitmap：行锁位信息，大小是 <strong>记录数+64</strong>；(可在批量更新时，节约创建锁的空间；)</li><li>heap：bitmap的下标对应于相应行，值为1，即加锁；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 死锁 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何避免MySQL死锁（三）- SQL语句与锁</title>
      <link href="/2019/01/07/avoid-mysql-deadlock-3/"/>
      <url>/2019/01/07/avoid-mysql-deadlock-3/</url>
      
        <content type="html"><![CDATA[<p>注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论<code>InnoDB</code>引擎。</p><ol><li><a href="/2019/01/06/avoid-mysql-deadlock-1/">如何避免MySQL死锁（一）- 引子</a></li><li><a href="/2019/01/06/avoid-mysql-deadlock-2/">如何避免MySQL死锁（二）- MySQL锁</a></li><li><a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a></li><li><a href="/2019/01/08/avoid-mysql-deadlock-4/">如何避免MySQL死锁（四）- 阅读死锁日志</a></li><li><a href="/2019/01/11/avoid-mysql-deadlock-5/">如何避免MySQL死锁（五）- 实例分析</a></li></ol><hr><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h2><p>将事务分解成加锁和解锁两个阶段：</p><ol><li>加锁<br>该阶段可以进行加锁操作，在对任何数据进行读操作之前要申请并获得S锁；而在进行写操作之前，需要申请X锁。加锁不成功则进入等待状态，而不能再加其它锁。</li><li>解锁<br>事务进入解锁阶段将释放其持有的锁，该阶段只能进行解锁操作，而不能再加其它锁。</li></ol><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>事务实现了不同的隔离级别，如下：</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>是</td><td>是</td><td>是</td></tr><tr><td>Read Committed</td><td>-</td><td>是</td><td>是</td></tr><tr><td>Repeatable Read</td><td>-</td><td>-</td><td>是</td></tr><tr><td>Serializable</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>问题解释如下：</p><ul><li>脏读：一个事务处理过程里读取了另一个未提交的事务中的数据。</li><li>不可重复读：对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li><li>幻读：主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。</li></ul><p>特别的，<code>RR</code>可重复读的级别可以部分解决幻读问题：</p><ul><li><code>快照读</code>使用了MVCC, 所以也就避免了部分幻读的出现！「读取后被删除，重新插入之类」</li><li><code>当前读</code>使用了Gap锁，解决幻读。</li></ul><p>但是<code>RR</code>无法解决如下情况的幻读：</p><table><thead><tr><th>事务一</th><th>事务二</th></tr></thead><tbody><tr><td>begin</td><td>begin</td></tr><tr><td>select * from demo;</td><td></td></tr><tr><td></td><td>insert into demo(id) values(1);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from demo;</td><td></td></tr><tr><td>insert into demo(id) values(1);</td><td></td></tr><tr><td>查询不到id为1的记录，插入却报错</td><td>-</td></tr></tbody></table><h1 id="SQL语句加锁"><a href="#SQL语句加锁" class="headerlink" title="SQL语句加锁"></a>SQL语句加锁</h1><h2 id="1-Consistent-Reads-–-一致性读、快照读"><a href="#1-Consistent-Reads-–-一致性读、快照读" class="headerlink" title="1. Consistent Reads – 一致性读、快照读"></a>1. Consistent Reads – 一致性读、快照读</h2><ul><li>select … from<ul><li>(<strong>非SERIALIZABLE</strong>) 快照读，不加锁</li><li>(<strong>SERIALIZABLE</strong>) 加锁</li></ul></li></ul><h2 id="2-Locking-Reads-–-当前读"><a href="#2-Locking-Reads-–-当前读" class="headerlink" title="2. Locking Reads – 当前读"></a>2. Locking Reads – 当前读</h2><ul><li>delete语句(<strong>RC</strong>情况下没有GAP锁)<ul><li>不存在，GAP锁</li><li>记录存在有删除标记，NK锁</li><li>记录存在<ul><li>非唯一索引：NK锁</li><li>唯一索引：REC锁</li></ul></li></ul></li><li>update同delete</li><li>insert语句<ul><li>插入意向锁(特殊的GAP锁)</li><li>特别的唯一键：要先做唯一键校验 - NK共享锁</li></ul></li></ul><h1 id="影响要素"><a href="#影响要素" class="headerlink" title="影响要素"></a>影响要素</h1><p>SQL语句如何加锁主要受以下两个关键要素的影响：</p><ul><li>事务隔离级别<ul><li><strong>RR</strong>:<ul><li>针对幻读问题，加NK锁</li><li>如果是能命中的<code>等值查询</code>，聚簇索引和唯一索引只加REC锁</li></ul></li><li><strong>RC</strong>:<ul><li>一般不加Gap锁</li></ul></li></ul></li><li>索引(InnoDB的行级锁锁的是索引)：查询是否走索引？什么类型的索引<ul><li><strong>正常情况下，如果查询使用的是辅助索引，会同时在满足条件的聚簇索引项上加上REC锁。</strong></li></ul></li></ul><h1 id="SQL操作的执行流程"><a href="#SQL操作的执行流程" class="headerlink" title="SQL操作的执行流程"></a>SQL操作的执行流程</h1><p><strong>InnoDB与MySQL是逐条交互，逐条加锁</strong>:</p><ul><li>根据where条件，读取第一条满足条件的记录；</li><li>返回并加锁，<code>Current Read</code>；</li><li>加锁后发起update/delete之类的操作<ul><li>insert操作可能会触发Unique Key的冲突检查，也会进行<code>Current Read</code>;</li></ul></li><li>成功后，再读取下一条，直到没有满足的记录。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html" target="_blank" rel="noopener">官方文档 - innodb如何加锁</a></li><li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">何登成 - MySQL加锁处理分析</a></li><li><a href="http://www.fordba.com/lock-analyse-of-delete.html" target="_blank" rel="noopener">MySQL DELETE 删除语句加锁分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 死锁 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何避免MySQL死锁（二）- MySQL锁</title>
      <link href="/2019/01/06/avoid-mysql-deadlock-2/"/>
      <url>/2019/01/06/avoid-mysql-deadlock-2/</url>
      
        <content type="html"><![CDATA[<p>注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论<code>InnoDB</code>引擎。</p><ol><li><a href="/2019/01/06/avoid-mysql-deadlock-1/">如何避免MySQL死锁（一）- 引子</a></li><li><a href="/2019/01/06/avoid-mysql-deadlock-2/">如何避免MySQL死锁（二）- MySQL锁</a></li><li><a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a></li><li><a href="/2019/01/08/avoid-mysql-deadlock-4/">如何避免MySQL死锁（四）- 阅读死锁日志</a></li><li><a href="/2019/01/11/avoid-mysql-deadlock-5/">如何避免MySQL死锁（五）- 实例分析</a></li></ol><hr><p>MySQL的锁，从性质来讲可以分为读锁、写锁；从粒度来讲可以分表锁、页锁、行锁；从细节上来讲可以分为记录锁、Gap锁、Next-Key锁、插入意向锁。</p><p>本节，我们从以下两个角度来解析：</p><ol><li>什么锁（重点在于锁的性质）</li><li>锁什么（重点在于锁的粒度）</li></ol><h1 id="1-什么锁"><a href="#1-什么锁" class="headerlink" title="1. 什么锁"></a>1. 什么锁</h1><p>采用了<a href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%86%99%E9%94%81" target="_blank" rel="noopener">读写锁</a>的设计，区别读、写操作。如下：</p><ul><li>Shared Lock(S)：共享锁，读锁。（允许多个读，写需等待。）</li><li>Exclusive Lock(X)：排他锁，写锁。（唯一许可。）</li></ul><h1 id="2-锁什么"><a href="#2-锁什么" class="headerlink" title="2. 锁什么"></a>2. 锁什么</h1><p>从锁的粒度来看，分为表锁、行锁以及介于两者之间的页锁，由于<code>InnoDB</code>只支持表锁和行锁，以下我们只讨论这两种。</p><h2 id="2-1-表锁"><a href="#2-1-表锁" class="headerlink" title="2.1 表锁"></a>2.1 表锁</h2><h3 id="2-1-1-Intention-Lock-意向锁"><a href="#2-1-1-Intention-Lock-意向锁" class="headerlink" title="2.1.1 Intention Lock - 意向锁"></a>2.1.1 Intention Lock - 意向锁</h3><p>首先要明确的是<strong>意向锁</strong>是表锁，代表了是否设置了表中的行级锁，是为了支持多种粒度锁同时存在而设计。</p><p>假设需要向一个表添加一个表级X锁：</p><ul><li>没有意向锁，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突；</li><li>有意向锁，则无需遍历，通过查询表锁之间是否互相兼容即可。</li></ul><p>意向锁表明一个事务稍后要获得针对<strong>一行记录</strong>的某种锁的对应表的表级锁，有两种：</p><ul><li>意向排它锁（简称 IX 锁）表明一个事务意图在某个表中设置某些行的 X 锁</li><li>意向共享锁（简称 IS 锁）表明一个事务意图在某个表中设置某些行的 S 锁</li></ul><p>兼容速查表如下，其中非意向的X锁和S锁为表级锁：</p><p><img src="/assets/images/mysql/intension-lock-compatible.jpg" alt="MySQL表锁兼容速查"></p><p>一言以敝之，意向锁之间必须走行锁粒度的检查才能知道是否兼容，但在表级兼容检查中都为兼容；其余情况遵循读写锁的规范即可。</p><h3 id="2-1-2-AUTO-INC-Locks-自增锁"><a href="#2-1-2-AUTO-INC-Locks-自增锁" class="headerlink" title="2.1.2 AUTO-INC Locks - 自增锁"></a>2.1.2 AUTO-INC Locks - 自增锁</h3><p>插入自增列时需要获取的表级锁。</p><h2 id="2-2-行锁"><a href="#2-2-行锁" class="headerlink" title="2.2 行锁"></a>2.2 行锁</h2><p><strong>注意：InnoDB的行锁是针对索引加锁。</strong>(InnoDB采用聚簇索引的方式构建，当没有主键时，优先找非空唯一列，如果没有，自动创建一个6字节的自增主键列。)</p><p>此处，请重点关注<strong>Gap Locks</strong>。</p><p><img src="/assets/images/mysql/row-lock.jpg" alt="行锁图示"></p><h3 id="2-2-1-Record-Locks-记录锁"><a href="#2-2-1-Record-Locks-记录锁" class="headerlink" title="2.2.1 Record Locks - 记录锁"></a>2.2.1 Record Locks - 记录锁</h3><p><code>LOCK_REC_NOT_GAP</code>，后文统称<code>REC锁</code>。</p><p>最简单的情况，只锁定单条记录。</p><h3 id="2-2-2-Gap-Locks-间隙锁"><a href="#2-2-2-Gap-Locks-间隙锁" class="headerlink" title="2.2.2 Gap Locks - 间隙锁"></a>2.2.2 Gap Locks - 间隙锁</h3><p><code>LOCK_GAP</code>，后文统称<code>GAP锁</code>。</p><p>最有意思的情况，锁定索引之间的内容。Gap锁设计的原因在于解决<a href="https://baike.baidu.com/item/%E5%B9%BB%E8%AF%BB" target="_blank" rel="noopener">幻读</a>的问题。</p><blockquote><p>关键：<strong>对于读取的范围加锁</strong>，且<strong>阻止插入操作</strong>。</p><ul><li>Gap锁不论S或X锁都可以互相兼容，可以同时持有</li><li>Gap锁只阻止插入，即插入意向锁！</li></ul></blockquote><p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-gap-locks" target="_blank" rel="noopener">MySQL官方关于Gap锁的解释</a>:</p><blockquote><p>Gap locks in InnoDB are “purely inhibitive”, which means that their only purpose is to prevent other transactions from inserting to the gap.<br>Gap locks can co-exist. A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other, and they perform the same function.</p></blockquote><p>注意：在<code>RC</code>级别下，search和index scans是不使用Gap锁的，只在外键约束和duplicate-key检查时使用。</p><h3 id="2-2-3-Next-Key锁"><a href="#2-2-3-Next-Key锁" class="headerlink" title="2.2.3 Next-Key锁"></a>2.2.3 Next-Key锁</h3><p><code>LOCK_ORDINARY</code>，后文统称<code>NK锁</code>。</p><p>REC锁 + 其之前的GAP锁的组合。如GAP锁是区间<code>(a, b)</code>，则NK锁是区间<code>(a, b]</code>。</p><h3 id="2-2-4-插入意向锁"><a href="#2-2-4-插入意向锁" class="headerlink" title="2.2.4 插入意向锁"></a>2.2.4 插入意向锁</h3><p><code>LOCK_INSERT_INTENTION</code>，后文统称<code>插入意向锁</code>。</p><p>特殊的Gap锁，在插入一行记录之前设置，找到当前插入位置的Gap加锁即可。多个事务如果不是在间隙相同的位置就不用相互等待。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%86%99%E9%94%81" target="_blank" rel="noopener">读写锁 - 维基百科</a></li><li><a href="https://baike.baidu.com/item/%E5%B9%BB%E8%AF%BB" target="_blank" rel="noopener">幻读 - 百度百科</a></li><li><a href="https://segmentfault.com/a/1190000014071758" target="_blank" rel="noopener">InnoDB 锁 — 官方文档（翻译）</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html" target="_blank" rel="noopener">InnoDB Locking - 官方文档</a></li><li><a href="https://segmentfault.com/a/1190000014133576" target="_blank" rel="noopener">MySQL InnoDB锁机制全面解析分享</a></li><li><a href="https://www.zhihu.com/question/51513268" target="_blank" rel="noopener">InnoDB的意向锁的作用？</a></li><li><a href="http://mysql.taobao.org/monthly/2017/12/02/" target="_blank" rel="noopener">Innodb 锁子系统浅析</a></li><li><a href="http://mysql.taobao.org/monthly/2016/01/01/" target="_blank" rel="noopener">InnoDB 事务锁系统简介</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 死锁 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何避免MySQL死锁（一）- 引子</title>
      <link href="/2019/01/06/avoid-mysql-deadlock-1/"/>
      <url>/2019/01/06/avoid-mysql-deadlock-1/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>事情是这样开始的……</p><p>这两天，好友L同学接到新需求，通宵达旦，终于在deadline前顺利上线了。松口气一块约了个饭，话还没聊半晌，leader却来电话了，线上MySQL并发死锁，DBA把日志都发过来了，务必赶紧解决，饭未毕人已凉……</p><p>那如何避免出现MySQL死锁问题呢？于是萌生了写一个系列文章，查缺补漏的同时也总结一下对于MySQL死锁问题的理解。</p><h1 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h1><p>死锁是在并发场景下产生的，经典的「哲学家就餐问题」很好地抽象了并发过程中的资源竞争情况。</p><p>它可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。每两个哲学家之间有一只筷子。而他们只能使用自己左右手边的那两只筷子。<br><img src="/assets/images/mysql/philosopher.jpg" alt="哲学家就餐问题"></p><p>那么这个模型下的并发问题可以这样描述：</p><ul><li>死锁：每个哲学家都同时拿起左手的筷子，等待另一边的筷子</li><li>活锁：每个哲学家都同时拿起左手的筷子，然后发现拿不到另一边的筷子，于是都放下已拿起的筷子，周而复始……</li><li>饥饿：某个哲学家拿到两边的筷子之后，一直不放回，那他两边的哲学家就会一直处于饥饿状态</li></ul><p>死锁问题可以抽象为一个有向图，节点为线程/事务，有向边表示资源/锁的依赖或者等待关系，当图中出现环时，死锁即出现。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这个系列文章的思路是这样的设计的：</p><ol><li><a href="/2019/01/06/avoid-mysql-deadlock-1/">如何避免MySQL死锁（一）- 引子</a></li><li><a href="/2019/01/06/avoid-mysql-deadlock-2/">如何避免MySQL死锁（二）- MySQL锁</a>：首先得了解竞争的到底是什么？本节，我们将要介绍MySQL的锁的分类、级别。</li><li><a href="/2019/01/07/avoid-mysql-deadlock-3/">如何避免MySQL死锁（三）- SQL语句与锁</a>：了解了锁之后，就需要进一步了解不同SQL语句的加锁策略是怎么样的，才能知道发生了什么</li><li><a href="/2019/01/08/avoid-mysql-deadlock-4/">如何避免MySQL死锁（四）- 阅读死锁日志</a>：出了死锁问题，DBA把日志发过来了，那如何读懂死锁日志呢？</li><li><a href="/2019/01/11/avoid-mysql-deadlock-5/">如何避免MySQL死锁（五）- 实例分析</a>：实例分析、总结</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">哲学家就餐问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 死锁 </tag>
            
            <tag> 哲学家就餐 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序猿利器推荐</title>
      <link href="/2018/12/15/productivity/"/>
      <url>/2018/12/15/productivity/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/images/production.jpg" alt="效率工具"></p><p>工欲善其事，必先利其器，推荐一些自己常用的工具。</p><h1 id="程序猿"><a href="#程序猿" class="headerlink" title="程序猿"></a>程序猿</h1><ul><li><strong>5星</strong> Shadowsocks: 科学上网 </li><li><strong>5星</strong> Spacemacs: Vim + Emacs</li><li><strong>5星</strong> Dash「Mac Only」: 查阅API文档必备，结合<code>Alfred</code>食用效果更佳</li><li><strong>5星</strong> Proxifier「Mac Only」: 应用即使没有Proxy设置依然可以科学上网</li><li><strong>5星</strong> JupyterLab: Python必备</li><li><strong>5星</strong> Tampermonkey: Chrome插件，Hack网页必备</li><li><strong>5星</strong> Intellij IDEA: Java IDE</li></ul><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><ul><li><strong>5星</strong> iTerm「Mac Only」: Mac下很爽的终端程序</li><li><strong>5星</strong> oh-my-zsh: 终端增强，自动补全……</li><li><strong>5星</strong> htop: 服务器进程管理小能手</li><li><strong>5星</strong> tmux: 结合<code>oh-my-zsh</code>的插件，<code>ta</code>直接<code>attach</code>到指定会话</li><li><strong>5星</strong> mosh: 长时间连接server必备，断线自动恢复</li><li><strong>5星</strong> tldr: 指令的快速查询手册，Too Long Don’t Read</li><li><strong>4星</strong> mycli: 终端MySQL客户端，带Tab补全功能</li></ul><h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><ul><li><strong>5星</strong> Alfred: 强力推荐</li><li><strong>5星</strong> Pomodoro Time: 番茄工作法工具，可追踪每日各任务所用的番茄数</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><strong>6星</strong> <strong>Anki</strong>: 记忆工具，强烈推荐，可多平台同步使用！！！</li><li><strong>5星</strong> 网易云音乐</li><li><strong>5星</strong> 脑图工具：MindNode、XMind、FreeMind</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
