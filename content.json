{"meta":{"title":"01世界","subtitle":"「0和1的世界|从0到1」","description":null,"author":"hbiboluo","url":"https://www.hbiboluo.com"},"pages":[{"title":"关于我","date":"2018-10-24T08:23:44.000Z","updated":"2018-10-24T09:10:56.167Z","comments":false,"path":"about/index.html","permalink":"https://www.hbiboluo.com/about/index.html","excerpt":"","text":"biboluo昵称来源于霹雳布袋戏之「赮毕钵罗」，《霹雳开天记之创神篇》初登场。其中，「毕钵罗」乃菩提树的别名，为平朔新月城之王受「侠菩提」之托交给「赮毕钵罗」的菩提子，以承接其未完成的天命。 从业以来，主要使用Java和Python，业务系统、开发工具、AI平台皆有些许涉足，经验不深不浅，知识还暂时不够体系化，「逆水行舟」，记录、分享自己的相关整理。 不敢说学过阳明心学，怕自己的浅薄反傍了心学，对佛学亦感兴趣。"}],"posts":[{"title":"程序猿Mac、Linux工具推荐","slug":"productivity","date":"2018-01-04T16:00:00.000Z","updated":"2018-10-24T09:43:12.834Z","comments":true,"path":"2018/01/05/productivity/","link":"","permalink":"https://www.hbiboluo.com/2018/01/05/productivity/","excerpt":"","text":"程序猿 5星 Shadowsocks: 科学上网 5星 Spacemacs: Vim + Emacs 5星 Dash「Mac Only」: 查阅API文档必备，结合Alfred食用效果更佳 5星 Proxifier「Mac Only」: 应用即使没有Proxy设置依然可以科学上网 5星 JupyterLab: Python必备 5星 Tampermonkey: Chrome插件，Hack网页必备 终端 5星 iTerm「Mac Only」: Mac下很爽的终端程序 5星 oh-my-zsh: 终端增强，自动补全…… 5星 htop: 服务器进程管理小能手 5星 tmux: 结合oh-my-zsh的插件，ta直接attach到指定会话 5星 mosh: 长时间连接server必备，断线自动恢复 5星 tldr: 指令的快速查询手册，Too Long Don’t Read. 效率 5星 Alfred「Mac Only」: 强力推荐 其他 6星 Anki: 记忆工具，强烈推荐，可多平台同步使用！！！ 5星 网易云音乐 5星 脑图工具：MindNode、XMind、FreeMind","categories":[{"name":"其他","slug":"其他","permalink":"https://www.hbiboluo.com/categories/其他/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://www.hbiboluo.com/tags/效率/"}]},{"title":"Xposed快速指南","slug":"quick-start-xposed","date":"2017-08-09T16:00:00.000Z","updated":"2018-10-24T09:27:23.622Z","comments":true,"path":"2017/08/10/quick-start-xposed/","link":"","permalink":"https://www.hbiboluo.com/2017/08/10/quick-start-xposed/","excerpt":"","text":"Xposed是什么Xposed是一个动态修改Android运行时的框架。 “Zygote”进程「Android运行时核心」是在手机启动时由/init.rc脚本启动，由/system/bin/app_process加载所有classes并调用初始化方法。 而Xposed框架被安装后，一个扩展的app_process会被安装到/system/bin/目录，将添加额外的jar包/data/data/de.robv.android.xposed.installer/bin/XposedBridge.jar到classpath并在指定位置调用方法。XposedBridge进入了类加载的世界，就可以主宰VM了。 XposedBridge中的hookMethodNative方法是Xposed入口，调用handleHookedMethod处理具体逻辑，传递method信息，可以回调注册过该method的hook方法，对参数进行修改，修改运行结果等等。 环境准备 开发环境: Android Studio Xposed API精要de.robv.android.xposed包下的hook入口： IXposedHookZygoteInit: Zygote进程初始化Hook，一般Android启动时使用。 IXposedHookLoadPackage: 应用(Package)加载Hook，一般用于Hook特定应用的一些方法。 IXposedHookInitPackageResources: 当应用加载资源时的Hook. 而重要的一些方法都在de.robv.android.xposed.XposedHelpers类中，比如提供的findAndHookMethod可以hook方法，其中参数类型： Class全限定名 ClassLoader 方法名称 可变长的方法参数类型(class/class全限定名称string) Hook逻辑 de.robv.android.xposed.XC_MethodHook为before/after的hook. de.robv.android.xposed.XC_MethodReplacement为方法替换hook，可以通过returnConstant方法返回结果，或者使用replaceHookedMethod直接修改。 其中，被Hook的方法参数: de.robv.android.xposed.XC_MethodHook.MethodHookParam setResult和setThrowable方法可以修改返回值，注意当在before hook执行则跳过执行原方法。 thisObject可以获得当前对象 Xposed快速开发流程第一步：添加Xposed依赖已被发布到Bintray/jCenter中, 直接添加一个Gradle dependency即可。1234567repositories &#123; jcenter();&#125;dependencies &#123; provided 'de.robv.android.xposed:api:82'&#125; 第二步: 在AndroidManifest.xml添加Xposed模块声明如下，比较简单，不展开解析：） 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"de.robv.android.xposed.mods.tutorial\" android:versionCode=\"1\" android:versionName=\"1.0\" &gt; &lt;uses-sdk android:minSdkVersion=\"15\" /&gt; &lt;application android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" &gt; &lt;meta-data android:name=\"xposedmodule\" android:value=\"true\" /&gt; &lt;meta-data android:name=\"xposeddescription\" android:value=\"Easy example which makes the status bar clock red and adds a smiley\" /&gt; &lt;meta-data android:name=\"xposedminversion\" android:value=\"53\" /&gt; &lt;/application&gt;&lt;/manifest&gt; 第三步：编写Xposed Module代码逻辑1. 了解你需要hook的对象这一步才是真正考验的地方，如果能拿到源码就直接阅读源码吧，以下只讨论通过apk逆向工程的情况。以下步骤可跳着看:) 获取应用的package name以下两个方案是从目前运行的app中获取，如果你已经获取了apk，也可以查看AndroidManifest.xml获得： 方法一：通过adb shell的package manager获取所有package，方便但是仍然得猜1adb shell pm list package 方法二：打开应用后通过adb shell的dumpsys获得当前系统服务数据。请参考文末的参考文档了解具体用法。1234# 通过window服务adb shell dumpsys window w | grep mCurrentFocus# 或者通过activity服务adb shell dumpsys activity | grep -A 5 \"Stack #1:\" | grep Intent 获取应用的apk包，以便反编译这个途径也比较多，直接从应用商店下载也是不错的选项，如果不方便下载的，直接通过pm的list package -f查看，再通过pull从手机端同步apk到PC端。示例，假设我们要获取小米应用商店的apk包: 12adb shell pm list package -f | grep com.xiaomi.marketadb pull /system/app/MiuiSuperMarket/MiuiSuperMarket.apk ~/Downloads/ 反编译apk查看代码理解(略)这一块内容比较杂，可以google一下，mac用户可以使用Android Crack Tool进行反编译。 阅读反编译后的代码，理解关键逻辑，制定Hook方案TODO 2. 编写Hook代码TODO 第四步：编写assets/xposed_init，注册Module类以便xposed framework了解，每行一个全限定类名即可 第五步：打包安装，在Framework中启用Module并设置后重启即可TODO 参考 官方Wiki API参考文档 dumpsys的用法","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"快速指南","slug":"快速指南","permalink":"https://www.hbiboluo.com/tags/快速指南/"},{"name":"Android","slug":"Android","permalink":"https://www.hbiboluo.com/tags/Android/"},{"name":"Xposed","slug":"Xposed","permalink":"https://www.hbiboluo.com/tags/Xposed/"}]},{"title":"关于闭包","slug":"closure","date":"2015-01-09T16:00:00.000Z","updated":"2018-10-24T09:57:11.000Z","comments":true,"path":"2015/01/10/closure/","link":"","permalink":"https://www.hbiboluo.com/2015/01/10/closure/","excerpt":"","text":"维基百科之闭包 示例12345678910111213def make_counter(): i = 0 def counter(): # counter() is a closure nonlocal i i += 1 return i return counterc1 = make_counter()c2 = make_counter()print (c1(), c1(), c2(), c2())# -&gt; 1 2 1 2 定义闭包Closure是词法闭包的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。 另一种说法，闭包是由函数和及相关的引用环境组合而成的实体。 闭包在运行时可以有多个实例； 不同的引用环境和相同的函数组合可以产生不同的实例 某些语言表现上在函数中定义另一个函数，如果内部函数引用了外部函数的变量，则可能产生闭包。一旦外部函数被执行，一个闭包就形成。体现为：闭包中包含了内部函数的代码，以及所需的外部函数中的变量引用。 这里，所引用的变量称作上值(upvalue)。 典型的支持闭包的语言中，通常将函数当作第一类对象。（函数可以当作参数传递、可以作为返回值、可以绑定到变量名） 关键：上值(upvalue) 在给定函数调用的过程中，能够保持其持久性； 作用域仅限于包含它们的函数，无法从其他程序代码部分进行访问； 用途 因为闭包只有在被调用时才执行操作（“惰性求值”）； 多个函数可以使用一个相同的环境，通过改变环境可以相互交流； 信息隐藏（环境）； 实现方式最直接的想法应该是定义一个特殊的数据结构，保存函数指针 &amp; 非local变量的指针。 而使用函数调用栈的就比较困难了，因为外部函数在返回时出栈，依赖GC机制可以把外部函数的变量(闭包的非local变量)留存起来。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.hbiboluo.com/tags/Python/"},{"name":"JS","slug":"JS","permalink":"https://www.hbiboluo.com/tags/JS/"}]},{"title":"在压力下思考","slug":"thinking-in-pressure","date":"2014-03-06T16:00:00.000Z","updated":"2018-10-24T10:03:53.916Z","comments":true,"path":"2014/03/07/thinking-in-pressure/","link":"","permalink":"https://www.hbiboluo.com/2014/03/07/thinking-in-pressure/","excerpt":"","text":"今天参加了厂里组织的《全面管理你的工作压力》课程，本只想转换注意力借培训放松一下，不想却有很多感触，遂提笔记录。 我认为这是一次对我个人来说很精彩的培训，其实也并不是说它给你灌输新知识的多少，而是它们与你整理过的或者还在萌芽尚未整理的思想不谋而合。甚是愉悦~ AHA MomentMoment 1. 情绪ABC理论情绪 ABC理论中：A表示诱发性事件，B表示个体针对此诱发性事件产生的一些信念，即对这件事的一些看法、解释。C表示自己产生的情绪和行为的结果。 而通常人们会认为诱发事件A直接导致了人的情绪和行为结果C，发生了什么事就引起了什么情绪体验。然而，对不同的人，相同的事情会引起不同的情绪体验。 在此理论中，我们要调整和优化的就是B我们的信念。更多内容请google词条”情绪ABC理论” Moment 2. 潜在压力而在我们的生活中其实有很多潜在的压力，来自于一些曾计划要做或想做或未完成的事，它们慢慢在我们记忆的角落里积灰，偶尔才让我们想起却不愿意去触碰。但是他们永远占用我们记忆的角落。 像我们收拾屋子一样，也是时候收拾一下我们的硬盘了。List them，直面我们潜在的压力然后各个击破他们。 补充情绪ABC理论其实不只限于情绪，个人认为至少我这个个体，在发生一些活动时，也经常是A-&gt;C这个过程模式，旧的思维惯性引导着我们直接由因导果，确实提高了我们的处理效率，但是同时略显简单粗暴。 比较喜欢思考，走路、吃饭甚或睡眠，思考范围或小或大。在我的思维里，大道至简，殊途同归，有时候也会思考一下自己的行为模式，探究其原始的驱动力，而这个特质很大程度塑造了我。而思考在这里扮演的就是ABC理论中B信念的角色，所以我在分享会上把这个理论升华为思考模型。 北京这座城市的节奏较快，很多时候我们都忙着急匆匆地往前赶，忘了思考，忘了我们的初衷。希望大家在工作、生活的过程中，偶尔可以停下来思考一下。 回归压力问题我的工作角色比较杂，功能设计、代码实现、帮助文档编写、构建自动化构造平台并管理构造任务、搭建并维护产品知识库（目前为博客）、维护部门服务器、解决产品公共问题和疑难问题、解决合作伙伴及用户反馈问题、在好友圈中扮演技术救火英雄等等。当然，我热爱我所做的这些！ 但伴随而来的是各种角色不断渗入我的工作时间，让我的时间支离破碎。我觉得研发这件事情是快乐的，但是需要专注。而处理这些非计划事件又让我频繁切换上下文，以至于效率下降。 而在我的生活中，微博、微信、手机等等让我在享受科技带来便利的同时，也引入了更多碎片化的时间，习惯了在班车上刷微博，最近慢慢察觉被动接受了很多对我无用的信息。于是重新回归RSS，推送到kindle让我专注于阅读。 而我处理工作压力的方法，首先是认识并承认这些压力，然后采用给时间分段，保持单位时间段内的专注性。课堂上听说了蕃茄工作法，知乎一下，亦有不谋而合之处。后续可以深入尝试一下。 目前，需要一个辅助我进行此类时间管理的工具，是否有推荐的？（我希望其一方便记录，其二支持多设备同步）Google日历？","categories":[{"name":"其他","slug":"其他","permalink":"https://www.hbiboluo.com/categories/其他/"}],"tags":[{"name":"思考","slug":"思考","permalink":"https://www.hbiboluo.com/tags/思考/"}]},{"title":"Jekyll之道,Geek之道","slug":"dao-of-jekyll","date":"2013-04-23T16:00:00.000Z","updated":"2018-10-24T10:01:52.935Z","comments":true,"path":"2013/04/24/dao-of-jekyll/","link":"","permalink":"https://www.hbiboluo.com/2013/04/24/dao-of-jekyll/","excerpt":"","text":"自由的Jekyll初见Jekyll时它是和Github Pages在一起的，从一开始它在我耳畔就萦绕起geek的声音三日不绝。江南三月，杨柳依依，春风拂面，Jekyll就此婀娜行来~ 嗯，好好说话。Geek之道，在于热于探索，追求自由，Jekyll主要技术如YAML、MarkDown、Liquid都不属烂大街的东西，门槛有但都简单，在这个世界里你可以主宰所有，导航来个固定布局，主区域左右分栏，哦footer还要卖个萌，内容无论是以多媒体还是以文字为主，Jekyll毫无压力。 自由的味道是什么？久旱逢甘霖 - 简洁的MarkDown语法MarkDown的设定从最一开始就是适用于Web写作的工具，提供简洁的语法以便转换为HTML。 传统的HTML方式，把正文与tag混杂到一块，为了突出显示粗体不得不相开始和结束一个strong标签，更别论引用、代码高亮之类了。Docbook虽然标准，仍属XML系统，摆脱不了编写过于繁琐的劣势。 他乡遇故知 - 文本载体，易于版本控制动态语言一般都会选择数据库来保存内容，相信CSDN、JavaEye等博客内容都是如此处理的，即使能够导出估计最后导出的格式也是百花怒放之象。 Jekyll则是通过post生成静态的HTML以供部署，原始内容是以html或MarkDown组织的正文，特别适合纳入版本控制特别是Git这种分布式的版本控制体系，尽情享用！ 洞房花烛夜 - 编辑器之殇想想在号称所见即所得的Web上编写博客的场景吧，不能tab，设计个列表需要在工具栏上找啊找，你想做个链接，哦，他想加个图片，这些都不是灾难性的，当你点击发布或者保存草稿时,Oh Shit! 网络异常？服务器错误？这时，你肯定会有一种欲哭无泪的绝望，可惜无能为力。 再想象一下用你最得心应手的编辑器来写博客，你可以使用由此带来的所有特性。使用vi我可以毫不费力地处理去除粘贴过来代码多余的前置空白，可以使用宏，多么美好的一天啊~ 金榜提名时 - Github毫无疑问的压轴大戏。对我这种超轻度博客作者来讲，免费再加上Github这几个字母就足够了。你可以选择把site部署到其他服务器上，所以其实Github也不算是必选项。 然后，你可以用到之前提及的所有特性来建立你的项目主页、分享你的知识，并部署到各种http容器中，纯静态的内容从性能上来讲也拉开那些动态内容几条街，唯一的缺点是静态内容是基于你的post、page在部署前生成的，所以比较适合个人和中小企业。 入门指南 Jekyll Github Wiki The Quickest Way to Blog on GitHub Pages Markdown语法说明 搭建一个免费的，无限流量的Blog——github Pages和Jekyll入门 Google “Jekyll” 更多…","categories":[{"name":"其他","slug":"其他","permalink":"https://www.hbiboluo.com/categories/其他/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://www.hbiboluo.com/tags/效率/"}]}]}