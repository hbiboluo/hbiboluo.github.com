{"meta":{"title":"01世界","subtitle":"「0和1的世界|从0到1」","description":null,"author":"hbiboluo","url":"https://www.hbiboluo.com"},"pages":[{"title":"关于","date":"2018-10-24T08:23:44.000Z","updated":"2019-01-05T09:22:25.072Z","comments":false,"path":"about/index.html","permalink":"https://www.hbiboluo.com/about/index.html","excerpt":"","text":"biboluo昵称来源于霹雳布袋戏之「赮毕钵罗」，《霹雳开天记之创神篇》初登场。其中，「毕钵罗」乃菩提树的别名，为平朔新月城之王受「侠菩提」之托交给「赮毕钵罗」的菩提子，以承接其未完成的天命。 从业以来，主要使用Java和Python，业务系统、开发工具、AI平台皆有些许涉足，经验不深不浅，知识还暂时不够体系化，「01世界」，记录、分享自己的相关整理。 不敢说学过阳明心学，怕自己的浅薄反傍了心学，对佛学亦感兴趣。"},{"title":"书单 - 阅读历史","date":"2019-01-05T15:00:00.000Z","updated":"2019-01-05T16:01:34.634Z","comments":false,"path":"reading/index.html","permalink":"https://www.hbiboluo.com/reading/index.html","excerpt":"","text":"书名 豆瓣评分 类型 链接 阅读进度 学会提问 8.3 思维 豆瓣 - 万万没想到 8.2 思维 豆瓣 - 如何阅读一本书 8.4 方法 豆瓣 - 算法(第4版) 9.4 技术 豆瓣 - 万历十五年 8.9 历史 豆瓣 -"}],"posts":[{"title":"如何避免MySQL死锁（三）- SQL语句与锁","slug":"avoid-mysql-deadlock-3","date":"2019-01-07T15:00:00.000Z","updated":"2019-01-08T14:50:41.391Z","comments":true,"path":"2019/01/07/avoid-mysql-deadlock-3/","link":"","permalink":"https://www.hbiboluo.com/2019/01/07/avoid-mysql-deadlock-3/","excerpt":"","text":"注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论InnoDB引擎。 基础两阶段锁协议将事务分解成加锁和解锁两个阶段： 加锁该阶段可以进行加锁操作，在对任何数据进行读操作之前要申请并获得S锁；而在进行写操作之前，需要申请X锁。加锁不成功则进入等待状态，而不能再加其它锁。 解锁事务进入解锁阶段将释放其持有的锁，该阶段只能进行解锁操作，而不能再加其它锁。 事务的隔离级别事务实现了不同的隔离级别，如下： 事务隔离级别 脏读 不可重复读 幻读 Read Uncommitted 是 是 是 Read Committed - 是 是 Repeatable Read - - 是 Serializable - - - 问题解释如下： 脏读：一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读：对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 幻读：主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。 特别的，RR可重复读的级别可以部分解决幻读问题： 快照读使用了MVCC, 所以也就避免了部分幻读的出现！「读取后被删除，重新插入之类」 当前读使用了Gap锁，解决幻读。 但是RR无法解决如下情况的幻读： 事务一 事务二 begin begin select * from demo; insert into demo(id) values(1); commit; select * from demo; insert into demo(id) values(1); 查询不到id为1的记录，插入却报错 - 快照读与当前读 - 理解什么语句会加锁，加什么锁1. Consistent Reads – 一致性读、快照读 select … from (非SERIALIZABLE) 快照读，不加锁 (SERIALIZABLE) 加锁 (unique index) record locks (其他) next-key locks 2. Locking Reads – 当前读 select、update、delete select … for update | select … lock in share mode (RR) (unique index) record locks (其他) next-key locks (其他) record locks update … where …(同上) delete … where …(同上) insert insert (RR) gap locks (RC) record locks insert into T select … from S where … T表的insert锁同insert加锁方式 S表 (RC | SERIALIZABLE(innodb_locks_unsafe_for_binlog开启)) 快照读，不加锁 (其他) next-key locks 影响要素SQL语句如何加锁主要受以下两个关键要素的影响： 事务隔离级别 索引(InnoDB的行级锁锁的是索引)：查询是否走索引？什么类型的索引 不同索引的加锁方式由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。 查询使用索引 锁内容 聚簇索引 聚簇索引 + Lock 唯一索引 辅助索引 + Lock；聚簇索引 + Record Lock； 普通索引 辅助索引 + Next-Key Lock；聚簇索引 + Record Lock； 无索引 聚簇索引全表 + Next-Key Lock SQL操作的执行流程InnoDB与MySQL是逐条交互，逐条加锁: 根据where条件，读取第一条满足条件的记录，返回并加锁，Current Read； 加锁后发起update/delete之类的操作 insert操作可能会触发Unique Key的冲突检查，也会进行Current Read; 成功后，再读取下一条，直到没有满足的记录。 参考 官方文档 - innodb如何加锁 何登成 - MySQL加锁处理分析","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"}]},{"title":"如何避免MySQL死锁（二）- MySQL锁","slug":"avoid-mysql-deadlock-2","date":"2019-01-06T07:00:00.000Z","updated":"2019-01-08T00:42:43.195Z","comments":true,"path":"2019/01/06/avoid-mysql-deadlock-2/","link":"","permalink":"https://www.hbiboluo.com/2019/01/06/avoid-mysql-deadlock-2/","excerpt":"","text":"注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论InnoDB引擎。 MySQL的锁，从性质来讲可以分为读锁、写锁；从粒度来讲可以分表锁、页锁、行锁；从细节上来讲可以分为记录锁、Gap锁、Next-Key锁、插入意向锁。 本节，我们从以下两个角度来解析： 什么锁（重点在于锁的性质） 锁什么（重点在于锁的粒度） 1. 什么锁采用了读写锁的设计，区别读、写操作。如下： Shared Lock(S)：共享锁，读锁。（允许多个读，写需等待。） Exclusive Lock(X)：排他锁，写锁。（唯一许可。） 2. 锁什么从锁的粒度来看，分为表锁、行锁以及介于两者之间的页锁，由于InnoDB只支持表锁和行锁，以下我们只讨论这两种。 2.1 表锁2.1.1 Intention Lock - 意向锁首先要明确的是意向锁是表锁，代表了是否设置了表中的行级锁，是为了支持多种粒度锁同时存在而设计。 假设需要向一个表添加一个表级X锁： 没有意向锁，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突； 有意向锁，则无需遍历，通过查询表锁之间是否互相兼容即可。 意向锁表明一个事务稍后要获得针对一行记录的某种锁的对应表的表级锁，有两种： 意向排它锁（简称 IX 锁）表明一个事务意图在某个表中设置某些行的 X 锁 意向共享锁（简称 IS 锁）表明一个事务意图在某个表中设置某些行的 S 锁 兼容速查表如下，其中非意向的X锁和S锁为表级锁： 一言以敝之，意向锁之间必须走行锁粒度的检查才能知道是否兼容，但在表级兼容检查中都为兼容；其余情况遵循读写锁的规范即可。 2.1.2 AUTO-INC Locks - 自增锁插入自增列时需要获取的表级锁。 2.2 行锁注意：InnoDB的行锁是针对索引加锁。(InnoDB采用聚簇索引的方式构建，当没有主键时，优先找非空唯一列，如果没有，自动创建一个6字节的自增主键列。) 此处，请重点关注Gap Locks。 2.2.1 Record Locks - 记录锁LOCK_REC_NOT_GAP 最简单的情况，只锁定单条记录。 2.2.2 Gap Locks - 间隙锁LOCK_GAP 最有意思的情况，锁定索引之间的内容。Gap锁设计的原因在于解决幻读的问题。 关键：对于读取的范围加锁，且阻止插入操作。 注意：在RC级别下，search和index scans是不使用Gap锁的，只在外键约束和duplicate-key检查时使用。 2.2.3 Next-Key锁LOCK_ORDINARY 记录锁 + 记录锁之前的间隙锁的组合。如间隙锁是区间(a, b)，则Next-Key锁是区间(a, b]。 2.2.4 插入意向锁LOCK_INSERT_INTENTION 特殊的Gap锁，在插入一行记录之前设置，找到当前插入位置的Gap加锁即可。多个事务如果不是在间隙相同的位置就不用相互等待。 参考 读写锁 - 维基百科 幻读 - 百度百科 InnoDB 锁 — 官方文档（翻译） InnoDB Locking - 官方文档 MySQL InnoDB锁机制全面解析分享 InnoDB的意向锁的作用？ Innodb 锁子系统浅析 InnoDB 事务锁系统简介","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"}]},{"title":"如何避免MySQL死锁（一）- 引子","slug":"avoid-mysql-deadlock-1","date":"2019-01-06T04:00:00.000Z","updated":"2019-01-06T08:36:28.852Z","comments":true,"path":"2019/01/06/avoid-mysql-deadlock-1/","link":"","permalink":"https://www.hbiboluo.com/2019/01/06/avoid-mysql-deadlock-1/","excerpt":"","text":"引子事情是这样开始的…… 这两天，好友L同学接到新需求，通宵达旦，终于在deadline前顺利上线了。松口气一块约了个饭，话还没聊半晌，leader却来电话了，线上MySQL并发死锁，DBA把日志都发过来了，务必赶紧解决，饭未毕人已凉…… 那如何避免出现MySQL死锁问题呢？于是萌生了写一个系列文章，查缺补漏的同时也总结一下对于MySQL死锁问题的理解。 哲学家就餐问题死锁是在并发场景下产生的，经典的「哲学家就餐问题」很好地抽象了并发过程中的资源竞争情况。 它可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。每两个哲学家之间有一只筷子。而他们只能使用自己左右手边的那两只筷子。 那么这个模型下的并发问题可以这样描述： 死锁：每个哲学家都同时拿起左手的筷子，等待另一边的筷子 活锁：每个哲学家都同时拿起左手的筷子，然后发现拿不到另一边的筷子，于是都放下已拿起的筷子，周而复始…… 饥饿：某个哲学家拿到两边的筷子之后，一直不放回，那他两边的哲学家就会一直处于饥饿状态 死锁问题可以抽象为一个有向图，节点为线程/事务，有向边表示资源/锁的依赖或者等待关系，当图中出现环时，死锁即出现。 思路这个系列文章的思路是这样的设计的： 如何避免MySQL死锁（一）- 引子 如何避免MySQL死锁（二）- MySQL锁：首先得了解竞争的到底是什么？本节，我们将要介绍MySQL的锁的分类、级别。 如何避免MySQL死锁（三）- SQL语句与锁：了解了锁之后，就需要进一步了解不同SQL语句的加锁策略是怎么样的，才能知道发生了什么 如何避免MySQL死锁（四）- 如何阅读MySQL的死锁日志：出了死锁问题，DBA把日志发过来了，那如何读懂死锁日志呢？ 如何避免MySQL死锁（五）- 实例分析：验证与练习 如何避免MySQL死锁（六）- 解决MySQL死锁的一般原则：总结一些经验 参考 哲学家就餐问题","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"}]},{"title":"程序猿利器推荐","slug":"productivity","date":"2018-12-14T16:00:00.000Z","updated":"2019-01-05T17:05:34.472Z","comments":true,"path":"2018/12/15/productivity/","link":"","permalink":"https://www.hbiboluo.com/2018/12/15/productivity/","excerpt":"","text":"工欲善其事，必先利其器，推荐一些自己常用的工具。 程序猿 5星 Shadowsocks: 科学上网 5星 Spacemacs: Vim + Emacs 5星 Dash「Mac Only」: 查阅API文档必备，结合Alfred食用效果更佳 5星 Proxifier「Mac Only」: 应用即使没有Proxy设置依然可以科学上网 5星 JupyterLab: Python必备 5星 Tampermonkey: Chrome插件，Hack网页必备 5星 Intellij IDEA: Java IDE 终端 5星 iTerm「Mac Only」: Mac下很爽的终端程序 5星 oh-my-zsh: 终端增强，自动补全…… 5星 htop: 服务器进程管理小能手 5星 tmux: 结合oh-my-zsh的插件，ta直接attach到指定会话 5星 mosh: 长时间连接server必备，断线自动恢复 5星 tldr: 指令的快速查询手册，Too Long Don’t Read 4星 mycli: 终端MySQL客户端，带Tab补全功能 效率 5星 Alfred: 强力推荐 5星 Pomodoro Time: 番茄工作法工具，可追踪每日各任务所用的番茄数 其他 6星 Anki: 记忆工具，强烈推荐，可多平台同步使用！！！ 5星 网易云音乐 5星 脑图工具：MindNode、XMind、FreeMind","categories":[{"name":"其他","slug":"其他","permalink":"https://www.hbiboluo.com/categories/其他/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://www.hbiboluo.com/tags/效率/"},{"name":"工具","slug":"工具","permalink":"https://www.hbiboluo.com/tags/工具/"}]}]}