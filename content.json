{"meta":{"title":"01世界","subtitle":"「0和1的世界|从0到1」","description":null,"author":"hbiboluo","url":"https://www.hbiboluo.com"},"pages":[{"title":"关于","date":"2018-10-24T08:23:44.000Z","updated":"2019-01-05T09:22:25.072Z","comments":false,"path":"about/index.html","permalink":"https://www.hbiboluo.com/about/index.html","excerpt":"","text":"biboluo昵称来源于霹雳布袋戏之「赮毕钵罗」，《霹雳开天记之创神篇》初登场。其中，「毕钵罗」乃菩提树的别名，为平朔新月城之王受「侠菩提」之托交给「赮毕钵罗」的菩提子，以承接其未完成的天命。 从业以来，主要使用Java和Python，业务系统、开发工具、AI平台皆有些许涉足，经验不深不浅，知识还暂时不够体系化，「01世界」，记录、分享自己的相关整理。 不敢说学过阳明心学，怕自己的浅薄反傍了心学，对佛学亦感兴趣。"},{"title":"书单 - 阅读历史","date":"2019-01-05T15:00:00.000Z","updated":"2019-01-05T16:01:34.634Z","comments":false,"path":"reading/index.html","permalink":"https://www.hbiboluo.com/reading/index.html","excerpt":"","text":"书名 豆瓣评分 类型 链接 阅读进度 学会提问 8.3 思维 豆瓣 - 万万没想到 8.2 思维 豆瓣 - 如何阅读一本书 8.4 方法 豆瓣 - 算法(第4版) 9.4 技术 豆瓣 - 万历十五年 8.9 历史 豆瓣 -"}],"posts":[{"title":"如何避免MySQL死锁（五）- 实例分析","slug":"avoid-mysql-deadlock-5","date":"2019-01-11T15:00:00.000Z","updated":"2019-01-13T05:10:37.178Z","comments":true,"path":"2019/01/11/avoid-mysql-deadlock-5/","link":"","permalink":"https://www.hbiboluo.com/2019/01/11/avoid-mysql-deadlock-5/","excerpt":"","text":"注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论InnoDB引擎。 如何避免MySQL死锁（一）- 引子 如何避免MySQL死锁（二）- MySQL锁 如何避免MySQL死锁（三）- SQL语句与锁 如何避免MySQL死锁（四）- 阅读死锁日志 如何避免MySQL死锁（五）- 实例分析 准备新建表结构:123456CREATE TABLE `user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `U_name`(`name`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; 插入数据：12345insert into user(id, name) values (1, 'One'), (2, 'Two'), (3, 'Three'), (5, 'Five'); 注意模拟之后，rollback回滚事务。 总结1、加锁顺序问题1.1 显式：相同索引的加锁顺序 事务1 事务2 start transaction; start transaction; update user set name=’O’ where id=1; update user set name=’T’ where id=2; update user set name=’T’ where id=2; update user set name=’O’ where id=1; 1.2 隐式：不同索引的加锁顺序 事务1 事务2 start transaction; start transaction; update user set name=’O’ where id=1; update user set name=’T’ where name=’TWO’; update user set name=’T’ where id=2; update user set name=’O’ where name=’ONE’; 走不同的索引可能会导致在聚簇索引上的不同加锁顺序，以上的示例是简单的场景，实际场景上要非常注意以下情况： 即使是相同语句，不同value的查询可能也会走不同的索引，切记，具体要看日志来。走什么索引是由优化器决定。 2、锁升级delete标记导致的不同加锁策略，普通的等值查询加锁在RR事务级别下是这样的： 找到满足条件的记录：加REC锁 没找到满足条件的记录：加Gap锁 特别的，找到了满足条件的记录但是被标记为delete：加NK锁 前文如何避免MySQL死锁（三）- SQL语句与锁介绍了SQL语句是逐行加锁，逐行操作的。高并发情况下(3个事务及其以上)，可能会出现同时申请获取delete的REC锁，事务排队后获取时发现记录已被删除，将在不释放锁的前提下重新去获取Gap锁（二阶段锁协议），如果此时另一个事务已经提前去排队取NK锁，凉凉。。。 3、操作的非原子性3.1 唯一键插入的两过程 先进行一次唯一键的冲突检测，加 (LOCK_GAP | LOCK_REC | LOCK_S)，共享锁 然后才获取插入意向锁，加(LOCK_INSERT_INTENTION | LOCK_GAP | LOCK_X )，写锁 事务1 事务2 事务3 start transaction; start transaction; start transaction; insert into user values(6, ‘Six’) insert into user values(6, ‘Six’) insert into user values(6, ‘Six’) rollback; - - 事务2、3同时持有共享的NK锁，插入意向锁循环等待。（除了以上示例，高并发场景下，有可能出现） 3.2 删除(等值查询)的两过程 获取REC锁 标记为删除 参见：「2、锁升级」 4、先删除再插入特别是在删除找不到记录导致加Gap锁的前提下，由于Gap锁之间互相兼容，可以同时持有，容易造成插入意向锁循环等待。 delete加Gap锁，兼容同时持有 insert加插入意向锁，循环等待 事务1 事务2 start transaction; start transaction; delete from user where id=10; delete from user where id=11; insert into user values(10, ‘Ten’); insert into user values(11, ‘Eleven’); 参考 一些deadlock事例及说明","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"},{"name":"死锁","slug":"死锁","permalink":"https://www.hbiboluo.com/tags/死锁/"}]},{"title":"如何避免MySQL死锁（四）- 阅读死锁日志","slug":"avoid-mysql-deadlock-4","date":"2019-01-08T15:00:00.000Z","updated":"2019-01-13T05:10:20.428Z","comments":true,"path":"2019/01/08/avoid-mysql-deadlock-4/","link":"","permalink":"https://www.hbiboluo.com/2019/01/08/avoid-mysql-deadlock-4/","excerpt":"","text":"注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论InnoDB引擎。 如何避免MySQL死锁（一）- 引子 如何避免MySQL死锁（二）- MySQL锁 如何避免MySQL死锁（三）- SQL语句与锁 如何避免MySQL死锁（四）- 阅读死锁日志 如何避免MySQL死锁（五）- 实例分析 死锁日志死锁剧本，默认RR级别： 事务1 事务2 start transaction; start transaction; update user set name=’A’ where id=1; update user set name=’B’ where id=2; update user set name=’B’ where id=2; update user set name=’A’ where id=1; 查看日志：1show engine innodb status; 日志如下：1234567891011121314151617181920212223242526272829303132333435363738394041------------------------LATEST DETECTED DEADLOCK------------------------2019-01-08 23:34:39 0x70000e32b000*** (1) TRANSACTION:TRANSACTION 1017613, ACTIVE 35 sec starting index readmysql tables in use 1, locked 1LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1MySQL thread id 4, OS thread handle 123145539956736, query id 261 localhost 127.0.0.1 root updatingupdate user set name=&apos;B&apos; where id=2*** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017613 lock_mode X locks rec but not gap waitingRecord lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0 0: len 4; hex 00000002; asc ;; 1: len 6; hex 0000000f870e; asc ;; 2: len 7; hex 2b000005eb1da8; asc + ;; 3: len 1; hex 42; asc B;;*** (2) TRANSACTION:TRANSACTION 1017614, ACTIVE 21 sec starting index readmysql tables in use 1, locked 13 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1MySQL thread id 7, OS thread handle 123145540513792, query id 262 localhost 127.0.0.1 root updatingupdate user set name=&apos;A&apos; where id=1*** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017614 lock_mode X locks rec but not gapRecord lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0 0: len 4; hex 00000002; asc ;; 1: len 6; hex 0000000f870e; asc ;; 2: len 7; hex 2b000005eb1da8; asc + ;; 3: len 1; hex 42; asc B;;*** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017614 lock_mode X locks rec but not gap waitingRecord lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0 0: len 4; hex 00000001; asc ;; 1: len 6; hex 0000000f870d; asc ;; 2: len 7; hex 2a00000620080a; asc * ;; 3: len 1; hex 41; asc A;;*** WE ROLL BACK TRANSACTION (2) 日志解析Transaction段123456789101112TRANSACTION 1017613, ACTIVE 35 sec starting index read 解析：事务ID + 事务状态mysql tables in use 1, locked 1 解析：操作表计数 - 使用数，锁定数LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1 解析：(执行状态 LOCK WAIT)，重点关注： - &quot;%lu row lock(s)&quot;: 持有多少行锁，通过遍历lock structs获得计数（特别注意：包含了waiting状态的锁） - &quot;undo log entries %lu&quot;: 共有多少个undo日志，更新了多少行，会影响死锁的事务牺牲判定。MySQL thread id 4, OS thread handle 123145539956736, query id 261 localhost 127.0.0.1 root updating 解析：线程信息，query id以及客户端、用户信息等update user set name=&apos;B&apos; where id=2 解析：当前query语句 Lock段1234567891011RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017613 lock_mode X locks rec but not gap waiting 解析：Lock的页信息，索引、加锁的类型、是否waiting - lock_mode X：NK锁 - lock_mode X locks rec but not gap: REC锁 - lock_mode X locks gap before rec：Gap锁Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0 0: len 4; hex 00000002; asc ;; 1: len 6; hex 0000000f870e; asc ;; 2: len 7; hex 2b000005eb1da8; asc + ;; 3: len 1; hex 42; asc B;; 解析：锁的具体信息 附：锁结构 - loc_rec_t:以下内容，与InnoDB的事务、锁的内部结构有关。 loc_rec_t是具体存放加锁信息的结构： space、page_no：指定页（InnoDB存储的最小单元，一页中多行数据以链表方式按索引顺序连接） bitmap：行锁位信息，大小是 记录数+64；(可在批量更新时，节约创建锁的空间；) heap：bitmap的下标对应于相应行，值为1，即加锁；","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"},{"name":"死锁","slug":"死锁","permalink":"https://www.hbiboluo.com/tags/死锁/"},{"name":"运维","slug":"运维","permalink":"https://www.hbiboluo.com/tags/运维/"}]},{"title":"如何避免MySQL死锁（三）- SQL语句与锁","slug":"avoid-mysql-deadlock-3","date":"2019-01-07T15:00:00.000Z","updated":"2019-01-13T05:10:06.232Z","comments":true,"path":"2019/01/07/avoid-mysql-deadlock-3/","link":"","permalink":"https://www.hbiboluo.com/2019/01/07/avoid-mysql-deadlock-3/","excerpt":"","text":"注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论InnoDB引擎。 如何避免MySQL死锁（一）- 引子 如何避免MySQL死锁（二）- MySQL锁 如何避免MySQL死锁（三）- SQL语句与锁 如何避免MySQL死锁（四）- 阅读死锁日志 如何避免MySQL死锁（五）- 实例分析 基础两阶段锁协议将事务分解成加锁和解锁两个阶段： 加锁该阶段可以进行加锁操作，在对任何数据进行读操作之前要申请并获得S锁；而在进行写操作之前，需要申请X锁。加锁不成功则进入等待状态，而不能再加其它锁。 解锁事务进入解锁阶段将释放其持有的锁，该阶段只能进行解锁操作，而不能再加其它锁。 事务的隔离级别事务实现了不同的隔离级别，如下： 事务隔离级别 脏读 不可重复读 幻读 Read Uncommitted 是 是 是 Read Committed - 是 是 Repeatable Read - - 是 Serializable - - - 问题解释如下： 脏读：一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读：对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 幻读：主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。 特别的，RR可重复读的级别可以部分解决幻读问题： 快照读使用了MVCC, 所以也就避免了部分幻读的出现！「读取后被删除，重新插入之类」 当前读使用了Gap锁，解决幻读。 但是RR无法解决如下情况的幻读： 事务一 事务二 begin begin select * from demo; insert into demo(id) values(1); commit; select * from demo; insert into demo(id) values(1); 查询不到id为1的记录，插入却报错 - SQL语句加锁1. Consistent Reads – 一致性读、快照读 select … from (非SERIALIZABLE) 快照读，不加锁 (SERIALIZABLE) 加锁 2. Locking Reads – 当前读 delete语句(RC情况下没有GAP锁) 不存在，GAP锁 记录存在有删除标记，NK锁 记录存在 非唯一索引：NK锁 唯一索引：REC锁 update同delete insert语句 插入意向锁(特殊的GAP锁) 特别的唯一键：要先做唯一键校验 - NK共享锁 影响要素SQL语句如何加锁主要受以下两个关键要素的影响： 事务隔离级别 RR: 针对幻读问题，加NK锁 如果是能命中的等值查询，聚簇索引和唯一索引只加REC锁 RC: 一般不加Gap锁 索引(InnoDB的行级锁锁的是索引)：查询是否走索引？什么类型的索引 正常情况下，如果查询使用的是辅助索引，会同时在满足条件的聚簇索引项上加上REC锁。 SQL操作的执行流程InnoDB与MySQL是逐条交互，逐条加锁: 根据where条件，读取第一条满足条件的记录； 返回并加锁，Current Read； 加锁后发起update/delete之类的操作 insert操作可能会触发Unique Key的冲突检查，也会进行Current Read; 成功后，再读取下一条，直到没有满足的记录。 参考 官方文档 - innodb如何加锁 何登成 - MySQL加锁处理分析 MySQL DELETE 删除语句加锁分析","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"},{"name":"死锁","slug":"死锁","permalink":"https://www.hbiboluo.com/tags/死锁/"},{"name":"事务","slug":"事务","permalink":"https://www.hbiboluo.com/tags/事务/"}]},{"title":"如何避免MySQL死锁（二）- MySQL锁","slug":"avoid-mysql-deadlock-2","date":"2019-01-06T07:00:00.000Z","updated":"2019-01-13T12:49:42.711Z","comments":true,"path":"2019/01/06/avoid-mysql-deadlock-2/","link":"","permalink":"https://www.hbiboluo.com/2019/01/06/avoid-mysql-deadlock-2/","excerpt":"","text":"注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论InnoDB引擎。 如何避免MySQL死锁（一）- 引子 如何避免MySQL死锁（二）- MySQL锁 如何避免MySQL死锁（三）- SQL语句与锁 如何避免MySQL死锁（四）- 阅读死锁日志 如何避免MySQL死锁（五）- 实例分析 MySQL的锁，从性质来讲可以分为读锁、写锁；从粒度来讲可以分表锁、页锁、行锁；从细节上来讲可以分为记录锁、Gap锁、Next-Key锁、插入意向锁。 本节，我们从以下两个角度来解析： 什么锁（重点在于锁的性质） 锁什么（重点在于锁的粒度） 1. 什么锁采用了读写锁的设计，区别读、写操作。如下： Shared Lock(S)：共享锁，读锁。（允许多个读，写需等待。） Exclusive Lock(X)：排他锁，写锁。（唯一许可。） 2. 锁什么从锁的粒度来看，分为表锁、行锁以及介于两者之间的页锁，由于InnoDB只支持表锁和行锁，以下我们只讨论这两种。 2.1 表锁2.1.1 Intention Lock - 意向锁首先要明确的是意向锁是表锁，代表了是否设置了表中的行级锁，是为了支持多种粒度锁同时存在而设计。 假设需要向一个表添加一个表级X锁： 没有意向锁，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突； 有意向锁，则无需遍历，通过查询表锁之间是否互相兼容即可。 意向锁表明一个事务稍后要获得针对一行记录的某种锁的对应表的表级锁，有两种： 意向排它锁（简称 IX 锁）表明一个事务意图在某个表中设置某些行的 X 锁 意向共享锁（简称 IS 锁）表明一个事务意图在某个表中设置某些行的 S 锁 兼容速查表如下，其中非意向的X锁和S锁为表级锁： 一言以敝之，意向锁之间必须走行锁粒度的检查才能知道是否兼容，但在表级兼容检查中都为兼容；其余情况遵循读写锁的规范即可。 2.1.2 AUTO-INC Locks - 自增锁插入自增列时需要获取的表级锁。 2.2 行锁注意：InnoDB的行锁是针对索引加锁。(InnoDB采用聚簇索引的方式构建，当没有主键时，优先找非空唯一列，如果没有，自动创建一个6字节的自增主键列。) 此处，请重点关注Gap Locks。 2.2.1 Record Locks - 记录锁LOCK_REC_NOT_GAP，后文统称REC锁。 最简单的情况，只锁定单条记录。 2.2.2 Gap Locks - 间隙锁LOCK_GAP，后文统称GAP锁。 最有意思的情况，锁定索引之间的内容。Gap锁设计的原因在于解决幻读的问题。 关键：对于读取的范围加锁，且阻止插入操作。 Gap锁不论S或X锁都可以互相兼容，可以同时持有 Gap锁只阻止插入，即插入意向锁！ MySQL官方关于Gap锁的解释: Gap locks in InnoDB are “purely inhibitive”, which means that their only purpose is to prevent other transactions from inserting to the gap.Gap locks can co-exist. A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other, and they perform the same function. 注意：在RC级别下，search和index scans是不使用Gap锁的，只在外键约束和duplicate-key检查时使用。 2.2.3 Next-Key锁LOCK_ORDINARY，后文统称NK锁。 REC锁 + 其之前的GAP锁的组合。如GAP锁是区间(a, b)，则NK锁是区间(a, b]。 2.2.4 插入意向锁LOCK_INSERT_INTENTION，后文统称插入意向锁。 特殊的Gap锁，在插入一行记录之前设置，找到当前插入位置的Gap加锁即可。多个事务如果不是在间隙相同的位置就不用相互等待。 参考 读写锁 - 维基百科 幻读 - 百度百科 InnoDB 锁 — 官方文档（翻译） InnoDB Locking - 官方文档 MySQL InnoDB锁机制全面解析分享 InnoDB的意向锁的作用？ Innodb 锁子系统浅析 InnoDB 事务锁系统简介","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"},{"name":"死锁","slug":"死锁","permalink":"https://www.hbiboluo.com/tags/死锁/"},{"name":"锁","slug":"锁","permalink":"https://www.hbiboluo.com/tags/锁/"}]},{"title":"如何避免MySQL死锁（一）- 引子","slug":"avoid-mysql-deadlock-1","date":"2019-01-06T04:00:00.000Z","updated":"2019-01-13T03:56:56.747Z","comments":true,"path":"2019/01/06/avoid-mysql-deadlock-1/","link":"","permalink":"https://www.hbiboluo.com/2019/01/06/avoid-mysql-deadlock-1/","excerpt":"","text":"引子事情是这样开始的…… 这两天，好友L同学接到新需求，通宵达旦，终于在deadline前顺利上线了。松口气一块约了个饭，话还没聊半晌，leader却来电话了，线上MySQL并发死锁，DBA把日志都发过来了，务必赶紧解决，饭未毕人已凉…… 那如何避免出现MySQL死锁问题呢？于是萌生了写一个系列文章，查缺补漏的同时也总结一下对于MySQL死锁问题的理解。 哲学家就餐问题死锁是在并发场景下产生的，经典的「哲学家就餐问题」很好地抽象了并发过程中的资源竞争情况。 它可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。每两个哲学家之间有一只筷子。而他们只能使用自己左右手边的那两只筷子。 那么这个模型下的并发问题可以这样描述： 死锁：每个哲学家都同时拿起左手的筷子，等待另一边的筷子 活锁：每个哲学家都同时拿起左手的筷子，然后发现拿不到另一边的筷子，于是都放下已拿起的筷子，周而复始…… 饥饿：某个哲学家拿到两边的筷子之后，一直不放回，那他两边的哲学家就会一直处于饥饿状态 死锁问题可以抽象为一个有向图，节点为线程/事务，有向边表示资源/锁的依赖或者等待关系，当图中出现环时，死锁即出现。 思路这个系列文章的思路是这样的设计的： 如何避免MySQL死锁（一）- 引子 如何避免MySQL死锁（二）- MySQL锁：首先得了解竞争的到底是什么？本节，我们将要介绍MySQL的锁的分类、级别。 如何避免MySQL死锁（三）- SQL语句与锁：了解了锁之后，就需要进一步了解不同SQL语句的加锁策略是怎么样的，才能知道发生了什么 如何避免MySQL死锁（四）- 阅读死锁日志：出了死锁问题，DBA把日志发过来了，那如何读懂死锁日志呢？ 如何避免MySQL死锁（五）- 实例分析：实例分析、总结 参考 哲学家就餐问题","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"},{"name":"死锁","slug":"死锁","permalink":"https://www.hbiboluo.com/tags/死锁/"},{"name":"哲学家就餐","slug":"哲学家就餐","permalink":"https://www.hbiboluo.com/tags/哲学家就餐/"}]},{"title":"程序猿利器推荐","slug":"productivity","date":"2018-12-14T16:00:00.000Z","updated":"2019-01-05T17:05:34.472Z","comments":true,"path":"2018/12/15/productivity/","link":"","permalink":"https://www.hbiboluo.com/2018/12/15/productivity/","excerpt":"","text":"工欲善其事，必先利其器，推荐一些自己常用的工具。 程序猿 5星 Shadowsocks: 科学上网 5星 Spacemacs: Vim + Emacs 5星 Dash「Mac Only」: 查阅API文档必备，结合Alfred食用效果更佳 5星 Proxifier「Mac Only」: 应用即使没有Proxy设置依然可以科学上网 5星 JupyterLab: Python必备 5星 Tampermonkey: Chrome插件，Hack网页必备 5星 Intellij IDEA: Java IDE 终端 5星 iTerm「Mac Only」: Mac下很爽的终端程序 5星 oh-my-zsh: 终端增强，自动补全…… 5星 htop: 服务器进程管理小能手 5星 tmux: 结合oh-my-zsh的插件，ta直接attach到指定会话 5星 mosh: 长时间连接server必备，断线自动恢复 5星 tldr: 指令的快速查询手册，Too Long Don’t Read 4星 mycli: 终端MySQL客户端，带Tab补全功能 效率 5星 Alfred: 强力推荐 5星 Pomodoro Time: 番茄工作法工具，可追踪每日各任务所用的番茄数 其他 6星 Anki: 记忆工具，强烈推荐，可多平台同步使用！！！ 5星 网易云音乐 5星 脑图工具：MindNode、XMind、FreeMind","categories":[{"name":"其他","slug":"其他","permalink":"https://www.hbiboluo.com/categories/其他/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://www.hbiboluo.com/tags/效率/"},{"name":"工具","slug":"工具","permalink":"https://www.hbiboluo.com/tags/工具/"}]}]}