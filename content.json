{"meta":{"title":"01世界","subtitle":"「0和1的世界|从0到1」","description":null,"author":"hbiboluo","url":"https://www.hbiboluo.com"},"pages":[{"title":"关于","date":"2018-10-24T08:23:44.000Z","updated":"2019-01-05T09:22:25.072Z","comments":false,"path":"about/index.html","permalink":"https://www.hbiboluo.com/about/index.html","excerpt":"","text":"biboluo昵称来源于霹雳布袋戏之「赮毕钵罗」，《霹雳开天记之创神篇》初登场。其中，「毕钵罗」乃菩提树的别名，为平朔新月城之王受「侠菩提」之托交给「赮毕钵罗」的菩提子，以承接其未完成的天命。 从业以来，主要使用Java和Python，业务系统、开发工具、AI平台皆有些许涉足，经验不深不浅，知识还暂时不够体系化，「01世界」，记录、分享自己的相关整理。 不敢说学过阳明心学，怕自己的浅薄反傍了心学，对佛学亦感兴趣。"},{"title":"书单","date":"2019-01-05T15:00:00.000Z","updated":"2019-02-22T01:05:09.040Z","comments":false,"path":"reading/index.html","permalink":"https://www.hbiboluo.com/reading/index.html","excerpt":"","text":"书名 豆瓣评分 类型 链接 阅读进度 2019年2月 - - - - 如何阅读一本书 8.4 方法 豆瓣 20190221 如何有效阅读一本书 7.4 方法 豆瓣 20190221 - - - - - TODO - - - - 格鲁夫给经理人的第一课(纪念版) 8.8 管理 豆瓣 … 卓有成效的管理者 8.7 管理 豆瓣 … 这就是搜索引擎 8.0 技术 豆瓣 - 万历十五年 8.9 历史 豆瓣 - 万万没想到 8.2 方法 豆瓣 - 高手 8.1 方法 豆瓣 - 刻意练习 7.9 方法 豆瓣 - 如何高效学习 7.4 方法 豆瓣 - 学会提问 8.3 思维 豆瓣 - 算法(第4版) 9.4 技术 豆瓣 -"}],"posts":[{"title":"读书笔记《认知天性》","slug":"make_it_stick","date":"2019-06-11T16:00:00.000Z","updated":"2019-06-13T00:35:39.409Z","comments":true,"path":"2019/06/12/make_it_stick/","link":"","permalink":"https://www.hbiboluo.com/2019/06/12/make_it_stick/","excerpt":"","text":"1、总结 学与用是硬币的两面，大多时候会误以为记住了即是学会了，而忽略了最终的使用场景，典型的如考试、解决问题……个人感觉本书最重要的点即是启发你关注学与用两个方向来学习。 2、笔记 让学习轻而易举的心理学规律 层次 内容 成果 外显、结果…… 方法 生成性学习（用自己的语言、不同语境……）； 练习（原则：合意困难）：间隔练习、穿插练习、多样性练习； 构建结构化知识 逻辑 知识链、记忆结；检索; 心态「成长型、勇心」;元认知「已知的已知、已知的未知、未知的未知 物理 神经学; 三元智力论「分析、创新、实践」; 错觉、误判、确认偏误「解决方案：客观标准」 小时候分享学习方法，只是基于外显的成果、结果往内去寻找其行为，以自身成果作为论据，颇不成熟。正常来看，支撑方法的就应当是就学习而言，其逻辑结构、运行原理是怎么样的，比如学习的模型、记忆的模型，适应、匹配该逻辑结构的才可能是好方法。而继续深究逻辑结构，是真真实实存在的物理结构、生物结构…… 2.1 物理 分析型智力是我们解决问题的能力，典型的例子就是解答测验中的问题；创新型智力是我们综合并应用现有的知识与技能，应对那些新的特殊情况的能力；实践型智力是我们适应日常生活的能力——明白在具体环境下需要做什么并行动，也就是我们所说的“街头智慧”。 三元智力论，能够解释一些现象，或许对于人才能力多维度评价等方面会有作用？ 这时候大脑会把你感知到的东西转化成化学与生物电形式的变化，这些变化就形成了一种心理表征。大脑是如何把感官感知到的东西转化为有意义的心理表征的，就目前来说，人类还不能完全理解这一过程。我们把这个过程叫作编码，同时把大脑中的这种新表征称为记忆痕迹，它就好比我们摘记的笔记或便签上的几句话，是短期记忆。 在巩固过程中，大脑会识别并稳定记忆痕迹，这可能会需要数小时或更长的时间，而且涉及对新资料的深层次处理。科学家认为，在这一过程中，大脑会重放或重新演练学到的东西，赋予其含义，填补空白，并把新知识和过去的经验联系起来，和已经存储在长期记忆中的其他知识关联起来。理解新知识的前提就是具备已知。另外，巩固也非常讲究搭建新旧知识间的关联。 类似于计算机，与用户交互的内容与最终存储是不同的，所以需要编码、转换；而人不同于计算机的是中间过程中有重演、填补空白、关联等，并且存储并非永久性的，也没有一个文件管理器，可以列举所有存储，需要不同的线索/索引才能导出。 人类有一种叙事的欲望。这种欲望源于我们对模棱两可与随机事件的不适，它塑造了我们对世界的理解。当意外发生时，我们会寻求解释。这种期望厘清事情的心理会非常急切，即便我们遇到的事情并不重要。 避开错觉和误判的办法是，用一组自身之外的客观标准，来替代用作决策参考的主观经验，这样我们的判断就能贴合周围的实际了。 错觉、误判、确认偏误等等，可以使用一组独立自身之外的客观标准作为参考。 2.2 逻辑 对失败的恐惧会导致学生厌恶尝试新事物，讨厌下功夫冒险，或是导致他们在面临测验等压力下表现不佳，这都会影响学习。就以测验为例，那些非常害怕在考试中犯错的学生，成绩可能真的会更糟糕，原因就是他们感到了焦虑。为什么会这样？这可能是因为他们把很大一部分工作记忆容量都浪费在监测自己的表现上了（我做得好不好？我是不是犯错了？），而分配给测验中解答问题的记忆容量则较少。“工作记忆”是指你在解决一个问题时，尤其是在有干扰的时候，头脑中能够保存的信息量。每个人的工作记忆都相当有限，有的人多些，有的人少些，更大的工作记忆容量意味着智商更高。 天赋测验和多数学习风格理论强调我们的长处，鼓励我们把精力放在长处上，而动态测验会帮助我们发现自身的不足并进行弥补。在日常生活中，挫折向我们指出了需要提高的地方。今后我们可以避开类似的挑战，或是加倍努力积累我们的经验，提升我们的能力，掌握应对挑战的技能。 重要的学问通常是有一定难度的，或者说基本都是如此。你会遭遇挫折，这是努力的标志，不代表失败。挫折伴随着奋斗，而奋斗可以积累专业知识。努力学习会改变你的大脑，创建新的连接，建立心智模型，扩展你的能力。你的智力在很大程度上由自己的控制，知道这一点非常重要，困难会因此变得有价值。 成长 &gt; 成果，不同的角度导向不同的结果。另外对于幼儿的教育，更要称赞其努力、过程…… 自以为掌握了所学，是元认知欠佳的一个例子。所谓元认知，就是指我们对知识掌握情况的理解。能准确判断知道什么和不知道什么，这对于做决策是至关重要的。美国前国防部部长唐纳德·拉姆斯菲尔德就总结过这个问题，他的这个说法为众人所熟知（同时也可以说是很有预见性）。在2002年的一次新闻发布会上，他说：“有些事是已知的已知——有的事情我们知道自己知道；有些事是已知的未知，意思是我们知道有的事情是自己不知道的。但是还有未知的未知——那些我们不知道自己不知道的事情。” 无法胜任某项工作的人缺乏提高自己的能力，因为他们分不清能与不能之间的区别。这种现象被称为“邓宁——克鲁格效应”，是元认知中一个较为热门的议题。 已知的已知、已知的未知，敬畏未知的未知。 2.3 方法 反复阅读有三大不足：浪费时间，无法产生持久的记忆，而且往往会让我们产生一种错觉——随着对所阅读的文本越发熟悉，我们以为自己已经掌握了内容。 为什么间隔练习比集中练习更为有效呢？大概是因为向长期记忆中存放新知识需要有一个巩固的过程。在这个过程中，记忆痕迹（大脑中有关新知识的心理表征）得到加深，被赋予含义，并和已知联系起来——这个过程需要数小时，甚至数天。快速频繁的练习会产生短期记忆，持久记忆则需要花时间进行心理演练以及其他巩固过程，因此有间隔的练习更为有效。出现了一些遗忘后，再检索所学的东西，就需要花费更多的力气，这会重新触发巩固过程，进一步强化记忆。 间隔多长时间才够？答案很简单：只要练习不是无意义的重复就可以。 穿插练习两样或更多的内容同样也提供了一种间隔。 首先，让练习增加一些难度，让人们做更多的努力，启用有间隔的、穿插安排的、多样化的练习，让表面上的成果来得慢一些。虽然这样做在当时会让人觉得收效不明显，但在之后却可以让学习成果更牢固、更准确，而且更持久。其次，我们在判断什么学习方法最适合自己的时候，通常会做出错误的决定，会受到自以为精通的错觉的影响。 练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。 刻意练习，刻意间隔、穿插、多样化的练习，警惕反复、集中练习。 表面的成果 vs. 真正能够实用的成果，更要关注后者，但同时也需要关注前者，学习过于痛苦长期看可能也会有负向结果。 发明了“合意困难”这个词的比约克夫妇写道，困难之所以必要，是因为“它们能触发编码和检索过程，从而支持学习、理解，以及记忆。 练习时合意困难很重要，过于简单没有意义，过于困难可能无效。 就学习运动技能来说，有一条理论是，如果立即反馈成了学习的一部分，那么等到真实环境下没有了这种反馈，学习者建立起来的模式就会出现缺失，进而影响表现。另一个观点是，反馈会频繁打断学习过程，带来太多变数，有碍学习者建立稳定的表现模式。 即便有时你会犯错，只要有纠正性反馈就没问题。 反馈是学习的重要部分，即时性也需要平衡，避免频繁打断，避免养成依赖。「例子：自行车辅轮」 最为有效的检索练习，是那些可以反映出你今后如何运用自己知识的检索练习。决定你今后知识运用水平的，不仅是你知道些什么，还有你如何将你的所知付诸实践。 背景可以激发记忆，想打开一把旧锁，就需要正确的钥匙。 检索知识的能力是关键能力。 反思会涉及多种认知活动，这些活动可以带来更好的学习效果：从记忆中检索知识或是早期的训练内容，把这些和新体验联系起来，借助观察和思考，预先演练你下次可能采取的不同做法。 反思涉及我们此前讨论过的数种认知活动，这些活动可以让我们更好地学习。这里包括检索（回忆最近学到的知识）、细化（例如把新知识和已知联系起来），以及生成（例如用自己的话重述核心观点，或是在心里、在行动上演练一下下次可以做哪些不同的事情）。 细化是在新资料中找到其他层面的含义的过程。 举例来说：把资料和你已知的东西联系起来，用自己的语言向别人解释，或者解释这些资料与你的课外生活有什么联系。 生成是指在得到答案或解决方案前，尝试回答疑问或解决问题。 反思、细化、生成…… 3、建议本书更多是在方法层面上做论述，而其论述依据则是一些看似不太严谨的实验、故事。另外一些观点在书中「穿插」出现，作者的解释是故意这么设计的，但是感觉信息量不大，原本可以拿很小篇幅说明的事情用了一本书的容量，很有畅销书的风采。不建议跟进阅读。。。","categories":[{"name":"读书","slug":"读书","permalink":"https://www.hbiboluo.com/categories/读书/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.hbiboluo.com/tags/读书笔记/"},{"name":"思维","slug":"思维","permalink":"https://www.hbiboluo.com/tags/思维/"}]},{"title":"读书笔记《金字塔原理》","slug":"pyramid_principle","date":"2019-04-23T16:00:00.000Z","updated":"2019-05-05T14:19:35.697Z","comments":true,"path":"2019/04/24/pyramid_principle/","link":"","permalink":"https://www.hbiboluo.com/2019/04/24/pyramid_principle/","excerpt":"","text":"0、总述：场景 x 结构工作生活中处处都有着场景：表达、提问、思考、解决问题、排兵布阵…… 当其内在没有一个结构来支撑时，往往让人感觉无重点、无逻辑，个人感觉本书的中心是：给场景赋予结构 场景 x 结构的意思是场景与结构中做迪卡尔积，不同场景更适合的结构是不同的，可以想象一个二维表，场景和结构的交叉处是其适用程度的得分。 另外，结构本身并不是单一结构，可以是复合的。 本书，从「金字塔」结构进行论述，并且不同的应用场景各有其不同特点。 1、原理：结构 - 金字塔五人为伍，二伍为什。 1.1 金字塔 - 树树结构对于各个节点延伸出了两个维度的信息： 纵向 关系 上统下：总结概括、疑问/回答 横向 关系 同一逻辑范畴 逻辑顺序排列「时间、结构、程度」 原则 MECE原则「互相独立、彼此穷尽」 1.2 如何构建 自上而下 自下而上 2、应用：场景 - 表达(写作)、思考、解决问题、演示2.1 表达 &amp; 演示此处把表达以及演示合并，共同点都在于是双向过程，在于以受众（听众、读者、观众等）为中心。 目标 吸引/保持受众注意力 减少受众的接受难度 策略 表达：序言（背景、冲突、疑问、答案）、结论先行、 演示：写好PPT，避免视觉朗诵…… 2.2 思考避免罗列、概括各组真义。 2.3 解决问题务必从问题出发： 界定问题「可映射到表达里的序言」 diff(现状, 目标) 结构化分析 四步曲 收集信息「收集发生在界定问题之后！」 描述发现 得出结论 提出方案 3、延伸3.1 结构延伸 图，从结构上来说比树更自由，可完成任意节点间的关联 结构「过于自由的模型，可以归纳为滥用反而事倍功半」 节点 连接 有向（单向、双向） – 更多信息 隐式 兄弟关系「并列」– 不如树直观 典型结构 流程图 图形结构 三角 矩形 五星 雁形 …… 3.2 应用延伸 流程图应用 组织架构 ……","categories":[{"name":"读书","slug":"读书","permalink":"https://www.hbiboluo.com/categories/读书/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.hbiboluo.com/tags/读书笔记/"},{"name":"思维","slug":"思维","permalink":"https://www.hbiboluo.com/tags/思维/"}]},{"title":"读书笔记《格鲁夫给经理人的第一课》","slug":"high_output_management","date":"2019-03-20T16:00:00.000Z","updated":"2019-05-05T14:00:47.373Z","comments":true,"path":"2019/03/21/high_output_management/","link":"","permalink":"https://www.hbiboluo.com/2019/03/21/high_output_management/","excerpt":"","text":"1、产出导向管理以产出为导向的管理，不论是组织管理还是个人管理。特别明确作为一个经理人，其产出是： 一个经理人的产出，便是他所管理或影响所及的部属工作的成效总和。 2、经理人2.1 核心公式 经理人的产出 = 组织产出的总和 = 杠杆率A×管理活动A＋杠杆率B×管理活动B…… 在这个等式中，经理人所从事的每一项管理活动（管理活动A、B……）对整个组织都有或多或少的影响。而对整个产出的影响有多大，则在于这项活动的杠杆率大小。一个经理人的产出便是这些乘积的加总。显而易见，为了有较高的产出，经理人应该把精力放在杠杆率较高的活动上。 经理人的生产力亦即其每个单位时间的产出，可通过以下3种方法来增加： 加快每一项活动进行的速度。 提高每一项活动的杠杆率。 调整管理活动的组合，摒除低杠杆率的活动，代之以高杠杆率的活动。 大都人都知道「要事第一」的原则，而困难的事情是识别什么是「要事」，经理人的产出公式恰恰指明了如何来识别要事。 2.1.1 杠杆率「提升每项活动的杠杆率」杠杆率：定义为对于产出的影响力。特别要注意，杠杆率可能为负。「个人定义：活动的产出」 确定了活动组合，不同的执行人收获的却是不同的产出，核心就在于对于每项活动，执行人带来的成果。如何提升杠杆率，避免负向作用？书中谈到高杠杆率主要是影响更多的人、产生更长远的影响。尝试抽象一下： 影响面「k, 累加」：对多少人产生直接/间接的影响。 影响度「x, 每个个体不一」：对一个人产生多大的影响，正向还是负向。 杠杆率 = Sum(Xi) 2.1.2 成本「加快活动速度，即是减小成本投入」在这个核心公式中，我们以杠杆率来衡量各项活动的产出，但是我们同时还需要关注投入的成本：特别是时间。 2.1.3 均衡活动的投入产出比「选择活动的艺术」构建一个 [成本, 产出, 产出/成本] 的三维空间，理论上可以寻找到一个 argmax(产出/成本) 的值。 在同一活动的三维空间中，尽量离 max(产出/成本) 近的点 在不同活动的选择中 尽量选择 max(产出/成本) 较高的活动 尽量选择在限定成本内，exp(产出/成本) 较高的活动 2.2 决策 我们希望决策是由离问题最近，而且最了解问题的人来制定。参考决策的制定过程，是每个经理人每日例行工作中非常重要的一环。 3 连接 - 管理/协作3.1 管理实践/认知3.1.1 控制模式“三个长官”： 自由市场因素：个人利益 契约义务：条文约束 文化价值观：价值观。当环境变化太快、规则无法及时应对时，个人的文化价值观便决定了我们的行动。「换个最简单的说法，文化价值观就是要形成个人对于团队利益的认同，并且愿意牺牲个人利益或者短期利益。长期牺牲或者不是双赢本身就是不合理的，那样是精神控制了。」 以下是书中提到的最合适的控制模式，主要受限于两个变量：1）个人关注的利益；2）CUA程度「CUA为Complexity、Uncertainty、Ambiguity」，用于衡量一个工作环境的复杂性、不确定性以及指令的模糊性。 CUA低 CUA高 关注团队利益 契约义务 文化价值观 关注个人利益 自由市场因素 / 3.1.2 工作成熟度及其对应的有效领导风格以下表格左侧摘自书内，是相对有效的领导风格，个人理解主要是对于放权及监督的权衡。 部属的工作成熟度 有效的领导风格 个人解读 高 组织化，任务导向，告诉员工该做什么，何时完成以及如何着手 重任务导向 中 注重个体，强调双向沟通，给予情绪上的支持及鼓励。上司与下属之间相互了解。 任务导向为主，过程监督为辅 低 经理人的参与程度降低；彼此建立起工作目标及监督系统。 重过程监督 工作成熟度越高，对部属的干涉越低； 不论哪个成熟度，都需要监督过程，这是授权之后经理人的责任； 放权 &amp; 监督； 3.2 信息交换交办、开会…… 口头、书面…… 3.2.1 开会 会议是人事管理工作必经的媒介。你绝对无法避免开会，但你能让会议更有效率。 「过程导向」会议，通常是例行的。 – 交换信息或技术 “规律化”是提升效率最好的方法。 「任务导向」会议，通常有决策产生。 – 解决特定问题 4、人员关注问题： 意愿：激励「以马斯洛的需求层次理论为基础」 能力：培训 其他：人员在职的生命周期：进 与 出。 5、其他5.1 双重报告在功能导向的组织中安置专业人员的一个最佳实践。 思考拿软件开发的过程来类比经理人的行为，有一些挺有意思的收获。 经理 = 一个功能模块，负责对外输出整体能力「包含了个体与整体的双重角色，简单定义为：类 -&gt; 模块 -&gt; 系统」 下属 = 类比为工具类/提供特定职责类，主要负责内部的具体某项内容「只包含个体的角色」 这个类比模型里， 可以反馈出一些共同点： 职责：需要对整个功能模块负责，包含了内部的所有类。 指派： 当调用某个类时，需要明确接口，包含输入、输出，以及性能。「对应指派任务的目标、验收点以及deadline。」 针对不同成熟度的工程师，会给予不同层面的自由度 实践： 测试：验收 多线程并发控制：协作 ……","categories":[{"name":"读书","slug":"读书","permalink":"https://www.hbiboluo.com/categories/读书/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.hbiboluo.com/tags/读书笔记/"},{"name":"管理","slug":"管理","permalink":"https://www.hbiboluo.com/tags/管理/"}]},{"title":"短评《如何阅读一本书》","slug":"how_to_read_a_book","date":"2019-02-20T16:00:00.000Z","updated":"2019-02-22T00:57:34.354Z","comments":true,"path":"2019/02/21/how_to_read_a_book/","link":"","permalink":"https://www.hbiboluo.com/2019/02/21/how_to_read_a_book/","excerpt":"","text":"简单总结《如何阅读一本书》中目前个人理解的要点。 主动阅读共识 书的金字塔原则：好书是有限的，知无涯而生有涯 聚焦在少数真正有提升的书籍 花合适的成本去阅读对应书籍 有必要在限定时间内了解一本书是否值得花更多时间、精力去研习 目的 阅读目标：学习、提升 阅读过程：从文字中理解作者想表达的的思想：主题、思路框架、主旨及论点…… 越是与目前能力有差距的书，越要付出更多的时间、精力以及理解力。 合理的期望：提升大的书，需要逐次逐步阅读。 避免口语主义：反模式是记住了原话，而没有理解真义。所以最好的方式是用自己的话来表达！ 阅读成果：阅读目标的答卷 学以致用 知行合一，深知深行，浅知浅行，不知不行 阅读方法这些方法是为指导我们阅读时要达成的小目标，也是作者理想的最佳实践。 完全遵循书中的规则偏理想，可以把它们看成是否完成该层次阅读的验收标准。 检视阅读 重点：限时！ 目标：了解主题、框架以及主要解决问题，以及是否有价值花更多时间做更完整的阅读。 要点： SOP：系统性略读 粗浅的阅读：在限定时间内，安排好时间、精力快速读完一遍 特别是在难懂的地方不要停下来，在价值不大的地方不要做太多投入 特别要注意找到作者自己的总结，一般在首章或末章 分析阅读完成以下内容： 书内 框架性 - 透视一本书 内容性 - 诠释一本书 书外 平等性 - 评断一本书","categories":[{"name":"读书","slug":"读书","permalink":"https://www.hbiboluo.com/categories/读书/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://www.hbiboluo.com/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.hbiboluo.com/tags/读书笔记/"}]},{"title":"如何避免MySQL死锁（五）- 实例分析","slug":"avoid-mysql-deadlock-5","date":"2019-01-11T15:00:00.000Z","updated":"2019-01-13T05:10:37.178Z","comments":true,"path":"2019/01/11/avoid-mysql-deadlock-5/","link":"","permalink":"https://www.hbiboluo.com/2019/01/11/avoid-mysql-deadlock-5/","excerpt":"","text":"注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论InnoDB引擎。 如何避免MySQL死锁（一）- 引子 如何避免MySQL死锁（二）- MySQL锁 如何避免MySQL死锁（三）- SQL语句与锁 如何避免MySQL死锁（四）- 阅读死锁日志 如何避免MySQL死锁（五）- 实例分析 准备新建表结构:123456CREATE TABLE `user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `U_name`(`name`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; 插入数据：12345insert into user(id, name) values (1, 'One'), (2, 'Two'), (3, 'Three'), (5, 'Five'); 注意模拟之后，rollback回滚事务。 总结1、加锁顺序问题1.1 显式：相同索引的加锁顺序 事务1 事务2 start transaction; start transaction; update user set name=’O’ where id=1; update user set name=’T’ where id=2; update user set name=’T’ where id=2; update user set name=’O’ where id=1; 1.2 隐式：不同索引的加锁顺序 事务1 事务2 start transaction; start transaction; update user set name=’O’ where id=1; update user set name=’T’ where name=’TWO’; update user set name=’T’ where id=2; update user set name=’O’ where name=’ONE’; 走不同的索引可能会导致在聚簇索引上的不同加锁顺序，以上的示例是简单的场景，实际场景上要非常注意以下情况： 即使是相同语句，不同value的查询可能也会走不同的索引，切记，具体要看日志来。走什么索引是由优化器决定。 2、锁升级delete标记导致的不同加锁策略，普通的等值查询加锁在RR事务级别下是这样的： 找到满足条件的记录：加REC锁 没找到满足条件的记录：加Gap锁 特别的，找到了满足条件的记录但是被标记为delete：加NK锁 前文如何避免MySQL死锁（三）- SQL语句与锁介绍了SQL语句是逐行加锁，逐行操作的。高并发情况下(3个事务及其以上)，可能会出现同时申请获取delete的REC锁，事务排队后获取时发现记录已被删除，将在不释放锁的前提下重新去获取Gap锁（二阶段锁协议），如果此时另一个事务已经提前去排队取NK锁，凉凉。。。 3、操作的非原子性3.1 唯一键插入的两过程 先进行一次唯一键的冲突检测，加 (LOCK_GAP | LOCK_REC | LOCK_S)，共享锁 然后才获取插入意向锁，加(LOCK_INSERT_INTENTION | LOCK_GAP | LOCK_X )，写锁 事务1 事务2 事务3 start transaction; start transaction; start transaction; insert into user values(6, ‘Six’) insert into user values(6, ‘Six’) insert into user values(6, ‘Six’) rollback; - - 事务2、3同时持有共享的NK锁，插入意向锁循环等待。（除了以上示例，高并发场景下，有可能出现） 3.2 删除(等值查询)的两过程 获取REC锁 标记为删除 参见：「2、锁升级」 4、先删除再插入特别是在删除找不到记录导致加Gap锁的前提下，由于Gap锁之间互相兼容，可以同时持有，容易造成插入意向锁循环等待。 delete加Gap锁，兼容同时持有 insert加插入意向锁，循环等待 事务1 事务2 start transaction; start transaction; delete from user where id=10; delete from user where id=11; insert into user values(10, ‘Ten’); insert into user values(11, ‘Eleven’); 参考 一些deadlock事例及说明","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"},{"name":"死锁","slug":"死锁","permalink":"https://www.hbiboluo.com/tags/死锁/"}]},{"title":"如何避免MySQL死锁（四）- 阅读死锁日志","slug":"avoid-mysql-deadlock-4","date":"2019-01-08T15:00:00.000Z","updated":"2019-01-13T05:10:20.428Z","comments":true,"path":"2019/01/08/avoid-mysql-deadlock-4/","link":"","permalink":"https://www.hbiboluo.com/2019/01/08/avoid-mysql-deadlock-4/","excerpt":"","text":"注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论InnoDB引擎。 如何避免MySQL死锁（一）- 引子 如何避免MySQL死锁（二）- MySQL锁 如何避免MySQL死锁（三）- SQL语句与锁 如何避免MySQL死锁（四）- 阅读死锁日志 如何避免MySQL死锁（五）- 实例分析 死锁日志死锁剧本，默认RR级别： 事务1 事务2 start transaction; start transaction; update user set name=’A’ where id=1; update user set name=’B’ where id=2; update user set name=’B’ where id=2; update user set name=’A’ where id=1; 查看日志：1show engine innodb status; 日志如下：1234567891011121314151617181920212223242526272829303132333435363738394041------------------------LATEST DETECTED DEADLOCK------------------------2019-01-08 23:34:39 0x70000e32b000*** (1) TRANSACTION:TRANSACTION 1017613, ACTIVE 35 sec starting index readmysql tables in use 1, locked 1LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1MySQL thread id 4, OS thread handle 123145539956736, query id 261 localhost 127.0.0.1 root updatingupdate user set name=&apos;B&apos; where id=2*** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017613 lock_mode X locks rec but not gap waitingRecord lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0 0: len 4; hex 00000002; asc ;; 1: len 6; hex 0000000f870e; asc ;; 2: len 7; hex 2b000005eb1da8; asc + ;; 3: len 1; hex 42; asc B;;*** (2) TRANSACTION:TRANSACTION 1017614, ACTIVE 21 sec starting index readmysql tables in use 1, locked 13 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1MySQL thread id 7, OS thread handle 123145540513792, query id 262 localhost 127.0.0.1 root updatingupdate user set name=&apos;A&apos; where id=1*** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017614 lock_mode X locks rec but not gapRecord lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0 0: len 4; hex 00000002; asc ;; 1: len 6; hex 0000000f870e; asc ;; 2: len 7; hex 2b000005eb1da8; asc + ;; 3: len 1; hex 42; asc B;;*** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017614 lock_mode X locks rec but not gap waitingRecord lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0 0: len 4; hex 00000001; asc ;; 1: len 6; hex 0000000f870d; asc ;; 2: len 7; hex 2a00000620080a; asc * ;; 3: len 1; hex 41; asc A;;*** WE ROLL BACK TRANSACTION (2) 日志解析Transaction段123456789101112TRANSACTION 1017613, ACTIVE 35 sec starting index read 解析：事务ID + 事务状态mysql tables in use 1, locked 1 解析：操作表计数 - 使用数，锁定数LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1 解析：(执行状态 LOCK WAIT)，重点关注： - &quot;%lu row lock(s)&quot;: 持有多少行锁，通过遍历lock structs获得计数（特别注意：包含了waiting状态的锁） - &quot;undo log entries %lu&quot;: 共有多少个undo日志，更新了多少行，会影响死锁的事务牺牲判定。MySQL thread id 4, OS thread handle 123145539956736, query id 261 localhost 127.0.0.1 root updating 解析：线程信息，query id以及客户端、用户信息等update user set name=&apos;B&apos; where id=2 解析：当前query语句 Lock段1234567891011RECORD LOCKS space id 240 page no 3 n bits 72 index PRIMARY of table `demo`.`user` trx id 1017613 lock_mode X locks rec but not gap waiting 解析：Lock的页信息，索引、加锁的类型、是否waiting - lock_mode X：NK锁 - lock_mode X locks rec but not gap: REC锁 - lock_mode X locks gap before rec：Gap锁Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0 0: len 4; hex 00000002; asc ;; 1: len 6; hex 0000000f870e; asc ;; 2: len 7; hex 2b000005eb1da8; asc + ;; 3: len 1; hex 42; asc B;; 解析：锁的具体信息 附：锁结构 - loc_rec_t:以下内容，与InnoDB的事务、锁的内部结构有关。 loc_rec_t是具体存放加锁信息的结构： space、page_no：指定页（InnoDB存储的最小单元，一页中多行数据以链表方式按索引顺序连接） bitmap：行锁位信息，大小是 记录数+64；(可在批量更新时，节约创建锁的空间；) heap：bitmap的下标对应于相应行，值为1，即加锁；","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"},{"name":"死锁","slug":"死锁","permalink":"https://www.hbiboluo.com/tags/死锁/"},{"name":"运维","slug":"运维","permalink":"https://www.hbiboluo.com/tags/运维/"}]},{"title":"如何避免MySQL死锁（三）- SQL语句与锁","slug":"avoid-mysql-deadlock-3","date":"2019-01-07T15:00:00.000Z","updated":"2019-01-13T05:10:06.232Z","comments":true,"path":"2019/01/07/avoid-mysql-deadlock-3/","link":"","permalink":"https://www.hbiboluo.com/2019/01/07/avoid-mysql-deadlock-3/","excerpt":"","text":"注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论InnoDB引擎。 如何避免MySQL死锁（一）- 引子 如何避免MySQL死锁（二）- MySQL锁 如何避免MySQL死锁（三）- SQL语句与锁 如何避免MySQL死锁（四）- 阅读死锁日志 如何避免MySQL死锁（五）- 实例分析 基础两阶段锁协议将事务分解成加锁和解锁两个阶段： 加锁该阶段可以进行加锁操作，在对任何数据进行读操作之前要申请并获得S锁；而在进行写操作之前，需要申请X锁。加锁不成功则进入等待状态，而不能再加其它锁。 解锁事务进入解锁阶段将释放其持有的锁，该阶段只能进行解锁操作，而不能再加其它锁。 事务的隔离级别事务实现了不同的隔离级别，如下： 事务隔离级别 脏读 不可重复读 幻读 Read Uncommitted 是 是 是 Read Committed - 是 是 Repeatable Read - - 是 Serializable - - - 问题解释如下： 脏读：一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读：对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 幻读：主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。 特别的，RR可重复读的级别可以部分解决幻读问题： 快照读使用了MVCC, 所以也就避免了部分幻读的出现！「读取后被删除，重新插入之类」 当前读使用了Gap锁，解决幻读。 但是RR无法解决如下情况的幻读： 事务一 事务二 begin begin select * from demo; insert into demo(id) values(1); commit; select * from demo; insert into demo(id) values(1); 查询不到id为1的记录，插入却报错 - SQL语句加锁1. Consistent Reads – 一致性读、快照读 select … from (非SERIALIZABLE) 快照读，不加锁 (SERIALIZABLE) 加锁 2. Locking Reads – 当前读 delete语句(RC情况下没有GAP锁) 不存在，GAP锁 记录存在有删除标记，NK锁 记录存在 非唯一索引：NK锁 唯一索引：REC锁 update同delete insert语句 插入意向锁(特殊的GAP锁) 特别的唯一键：要先做唯一键校验 - NK共享锁 影响要素SQL语句如何加锁主要受以下两个关键要素的影响： 事务隔离级别 RR: 针对幻读问题，加NK锁 如果是能命中的等值查询，聚簇索引和唯一索引只加REC锁 RC: 一般不加Gap锁 索引(InnoDB的行级锁锁的是索引)：查询是否走索引？什么类型的索引 正常情况下，如果查询使用的是辅助索引，会同时在满足条件的聚簇索引项上加上REC锁。 SQL操作的执行流程InnoDB与MySQL是逐条交互，逐条加锁: 根据where条件，读取第一条满足条件的记录； 返回并加锁，Current Read； 加锁后发起update/delete之类的操作 insert操作可能会触发Unique Key的冲突检查，也会进行Current Read; 成功后，再读取下一条，直到没有满足的记录。 参考 官方文档 - innodb如何加锁 何登成 - MySQL加锁处理分析 MySQL DELETE 删除语句加锁分析","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"},{"name":"死锁","slug":"死锁","permalink":"https://www.hbiboluo.com/tags/死锁/"},{"name":"事务","slug":"事务","permalink":"https://www.hbiboluo.com/tags/事务/"}]},{"title":"如何避免MySQL死锁（二）- MySQL锁","slug":"avoid-mysql-deadlock-2","date":"2019-01-06T07:00:00.000Z","updated":"2019-01-13T12:49:42.711Z","comments":true,"path":"2019/01/06/avoid-mysql-deadlock-2/","link":"","permalink":"https://www.hbiboluo.com/2019/01/06/avoid-mysql-deadlock-2/","excerpt":"","text":"注意：MySQL不同的存储引擎内部有不同的实现，本系列文章仅讨论InnoDB引擎。 如何避免MySQL死锁（一）- 引子 如何避免MySQL死锁（二）- MySQL锁 如何避免MySQL死锁（三）- SQL语句与锁 如何避免MySQL死锁（四）- 阅读死锁日志 如何避免MySQL死锁（五）- 实例分析 MySQL的锁，从性质来讲可以分为读锁、写锁；从粒度来讲可以分表锁、页锁、行锁；从细节上来讲可以分为记录锁、Gap锁、Next-Key锁、插入意向锁。 本节，我们从以下两个角度来解析： 什么锁（重点在于锁的性质） 锁什么（重点在于锁的粒度） 1. 什么锁采用了读写锁的设计，区别读、写操作。如下： Shared Lock(S)：共享锁，读锁。（允许多个读，写需等待。） Exclusive Lock(X)：排他锁，写锁。（唯一许可。） 2. 锁什么从锁的粒度来看，分为表锁、行锁以及介于两者之间的页锁，由于InnoDB只支持表锁和行锁，以下我们只讨论这两种。 2.1 表锁2.1.1 Intention Lock - 意向锁首先要明确的是意向锁是表锁，代表了是否设置了表中的行级锁，是为了支持多种粒度锁同时存在而设计。 假设需要向一个表添加一个表级X锁： 没有意向锁，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突； 有意向锁，则无需遍历，通过查询表锁之间是否互相兼容即可。 意向锁表明一个事务稍后要获得针对一行记录的某种锁的对应表的表级锁，有两种： 意向排它锁（简称 IX 锁）表明一个事务意图在某个表中设置某些行的 X 锁 意向共享锁（简称 IS 锁）表明一个事务意图在某个表中设置某些行的 S 锁 兼容速查表如下，其中非意向的X锁和S锁为表级锁： 一言以敝之，意向锁之间必须走行锁粒度的检查才能知道是否兼容，但在表级兼容检查中都为兼容；其余情况遵循读写锁的规范即可。 2.1.2 AUTO-INC Locks - 自增锁插入自增列时需要获取的表级锁。 2.2 行锁注意：InnoDB的行锁是针对索引加锁。(InnoDB采用聚簇索引的方式构建，当没有主键时，优先找非空唯一列，如果没有，自动创建一个6字节的自增主键列。) 此处，请重点关注Gap Locks。 2.2.1 Record Locks - 记录锁LOCK_REC_NOT_GAP，后文统称REC锁。 最简单的情况，只锁定单条记录。 2.2.2 Gap Locks - 间隙锁LOCK_GAP，后文统称GAP锁。 最有意思的情况，锁定索引之间的内容。Gap锁设计的原因在于解决幻读的问题。 关键：对于读取的范围加锁，且阻止插入操作。 Gap锁不论S或X锁都可以互相兼容，可以同时持有 Gap锁只阻止插入，即插入意向锁！ MySQL官方关于Gap锁的解释: Gap locks in InnoDB are “purely inhibitive”, which means that their only purpose is to prevent other transactions from inserting to the gap.Gap locks can co-exist. A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other, and they perform the same function. 注意：在RC级别下，search和index scans是不使用Gap锁的，只在外键约束和duplicate-key检查时使用。 2.2.3 Next-Key锁LOCK_ORDINARY，后文统称NK锁。 REC锁 + 其之前的GAP锁的组合。如GAP锁是区间(a, b)，则NK锁是区间(a, b]。 2.2.4 插入意向锁LOCK_INSERT_INTENTION，后文统称插入意向锁。 特殊的Gap锁，在插入一行记录之前设置，找到当前插入位置的Gap加锁即可。多个事务如果不是在间隙相同的位置就不用相互等待。 参考 读写锁 - 维基百科 幻读 - 百度百科 InnoDB 锁 — 官方文档（翻译） InnoDB Locking - 官方文档 MySQL InnoDB锁机制全面解析分享 InnoDB的意向锁的作用？ Innodb 锁子系统浅析 InnoDB 事务锁系统简介","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"},{"name":"死锁","slug":"死锁","permalink":"https://www.hbiboluo.com/tags/死锁/"},{"name":"锁","slug":"锁","permalink":"https://www.hbiboluo.com/tags/锁/"}]},{"title":"如何避免MySQL死锁（一）- 引子","slug":"avoid-mysql-deadlock-1","date":"2019-01-06T04:00:00.000Z","updated":"2019-01-13T03:56:56.747Z","comments":true,"path":"2019/01/06/avoid-mysql-deadlock-1/","link":"","permalink":"https://www.hbiboluo.com/2019/01/06/avoid-mysql-deadlock-1/","excerpt":"","text":"引子事情是这样开始的…… 这两天，好友L同学接到新需求，通宵达旦，终于在deadline前顺利上线了。松口气一块约了个饭，话还没聊半晌，leader却来电话了，线上MySQL并发死锁，DBA把日志都发过来了，务必赶紧解决，饭未毕人已凉…… 那如何避免出现MySQL死锁问题呢？于是萌生了写一个系列文章，查缺补漏的同时也总结一下对于MySQL死锁问题的理解。 哲学家就餐问题死锁是在并发场景下产生的，经典的「哲学家就餐问题」很好地抽象了并发过程中的资源竞争情况。 它可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。每两个哲学家之间有一只筷子。而他们只能使用自己左右手边的那两只筷子。 那么这个模型下的并发问题可以这样描述： 死锁：每个哲学家都同时拿起左手的筷子，等待另一边的筷子 活锁：每个哲学家都同时拿起左手的筷子，然后发现拿不到另一边的筷子，于是都放下已拿起的筷子，周而复始…… 饥饿：某个哲学家拿到两边的筷子之后，一直不放回，那他两边的哲学家就会一直处于饥饿状态 死锁问题可以抽象为一个有向图，节点为线程/事务，有向边表示资源/锁的依赖或者等待关系，当图中出现环时，死锁即出现。 思路这个系列文章的思路是这样的设计的： 如何避免MySQL死锁（一）- 引子 如何避免MySQL死锁（二）- MySQL锁：首先得了解竞争的到底是什么？本节，我们将要介绍MySQL的锁的分类、级别。 如何避免MySQL死锁（三）- SQL语句与锁：了解了锁之后，就需要进一步了解不同SQL语句的加锁策略是怎么样的，才能知道发生了什么 如何避免MySQL死锁（四）- 阅读死锁日志：出了死锁问题，DBA把日志发过来了，那如何读懂死锁日志呢？ 如何避免MySQL死锁（五）- 实例分析：实例分析、总结 参考 哲学家就餐问题","categories":[{"name":"技术","slug":"技术","permalink":"https://www.hbiboluo.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.hbiboluo.com/tags/MySQL/"},{"name":"死锁","slug":"死锁","permalink":"https://www.hbiboluo.com/tags/死锁/"},{"name":"哲学家就餐","slug":"哲学家就餐","permalink":"https://www.hbiboluo.com/tags/哲学家就餐/"}]},{"title":"程序猿利器推荐","slug":"productivity","date":"2018-12-14T16:00:00.000Z","updated":"2019-01-05T17:05:34.472Z","comments":true,"path":"2018/12/15/productivity/","link":"","permalink":"https://www.hbiboluo.com/2018/12/15/productivity/","excerpt":"","text":"工欲善其事，必先利其器，推荐一些自己常用的工具。 程序猿 5星 Shadowsocks: 科学上网 5星 Spacemacs: Vim + Emacs 5星 Dash「Mac Only」: 查阅API文档必备，结合Alfred食用效果更佳 5星 Proxifier「Mac Only」: 应用即使没有Proxy设置依然可以科学上网 5星 JupyterLab: Python必备 5星 Tampermonkey: Chrome插件，Hack网页必备 5星 Intellij IDEA: Java IDE 终端 5星 iTerm「Mac Only」: Mac下很爽的终端程序 5星 oh-my-zsh: 终端增强，自动补全…… 5星 htop: 服务器进程管理小能手 5星 tmux: 结合oh-my-zsh的插件，ta直接attach到指定会话 5星 mosh: 长时间连接server必备，断线自动恢复 5星 tldr: 指令的快速查询手册，Too Long Don’t Read 4星 mycli: 终端MySQL客户端，带Tab补全功能 效率 5星 Alfred: 强力推荐 5星 Pomodoro Time: 番茄工作法工具，可追踪每日各任务所用的番茄数 其他 6星 Anki: 记忆工具，强烈推荐，可多平台同步使用！！！ 5星 网易云音乐 5星 脑图工具：MindNode、XMind、FreeMind","categories":[{"name":"其他","slug":"其他","permalink":"https://www.hbiboluo.com/categories/其他/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://www.hbiboluo.com/tags/效率/"},{"name":"工具","slug":"工具","permalink":"https://www.hbiboluo.com/tags/工具/"}]}]}